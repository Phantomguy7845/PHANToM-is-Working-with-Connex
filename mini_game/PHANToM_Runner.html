<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <title>PHANToM Runner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
    }

    body.fullscreen-game{ padding-top: 12px; }

    h1 {
      margin-bottom: 8px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #hint {
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 12px;
      text-align: center;
      max-width: 900px;
      padding: 0 12px;
    }

    #gameContainer {
      position: relative;
      width: 800px;
      max-width: 95vw;
      height: 260px;
      border: 2px solid #4b5563;
      overflow: hidden;
      border-radius: 16px;
      background: radial-gradient(circle at top, #1d2337 0, #020617 55%, #020617 100%);
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.9);
    }

    #ground {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 200%;
      height: 40px;
      background: repeating-linear-gradient(
        -45deg,
        #6b7280 0,
        #6b7280 12px,
        #4b5563 12px,
        #4b5563 24px
      );
      animation: groundMove 1s linear infinite;
      opacity: 0.9;
      z-index: 1;
    }

    @keyframes groundMove {
      from { transform: translateX(0); }
      to   { transform: translateX(-50%); }
    }

    /* ==== ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ==== */
    #player {
      position: absolute;
      bottom: 40px;
      left: 80px;
      width: 60px;
      height: 60px;
      transform-origin: center bottom;
      transition: transform 0.08s ease, width 0.12s ease, height 0.12s ease;
      box-shadow: none;
      z-index: 5;
    }

    #player img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      background: transparent;
      filter: drop-shadow(0 0 16px rgba(56,189,248,0.8));
    }

    /* ‡∏´‡∏°‡∏≠‡∏ö */
    #player.duck {
      transform: translateY(-8px) scaleY(0.5);
    }
    #player.duck img {
      filter: drop-shadow(0 0 14px rgba(56,189,248,0.9));
    }

    /* ‡∏≠‡∏°‡∏ï‡∏∞ (‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á / Boost) */
    #player.invincible img {
      filter:
        drop-shadow(0 0 26px rgba(250,204,21,1))
        drop-shadow(0 0 70px rgba(250,204,21,0.7));
    }

    /* ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏£‡πà‡∏≤‡∏á (Giant) */
    #player.giant {
      width: 130px;
      height: 130px;
    }
    #player.giant img {
      filter:
        drop-shadow(0 0 26px rgba(59,130,246,1))
        drop-shadow(0 0 70px rgba(59,130,246,0.7));
    }

    /* ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå double jump: ‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏±‡∏ß */
    #player.double-jump img {
      animation: djumpSpin 0.2s linear;
    }

    @keyframes djumpSpin {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    /* ‡∏•‡∏≥‡πÅ‡∏™‡∏á‡∏ï‡∏≠‡∏ô Boost */
    #boostBeam {
      position: absolute;
      width: 140px;
      height: 35px;
      left: -9999px;
      bottom: 40px;
      background: linear-gradient(
        90deg,
        rgba(34,197,94,0),
        rgba(34,197,94,0.9),
        rgba(56,189,248,0.0)
      );
      filter: blur(8px);
      opacity: 0;
      transition: opacity 0.12s ease;
      pointer-events: none;
      z-index: 4;
      mix-blend-mode: screen;
    }

    .obstacle {
      position: absolute;
      bottom: 40px;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(15, 23, 42, 1);
      z-index: 3;
    }

    /* ‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡∏û‡∏∑‡πâ‡∏ô (‡πÅ‡∏ö‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ) */
    .obstacle.ground.tree { border-radius: 4px 4px 0 0; }
    .obstacle.ground.bush { border-radius: 16px; }
    .obstacle.ground.rock { border-radius: 40% 60% 30% 70%; }
    .obstacle.ground.spike { }
    .obstacle.ground.crate { }
    .obstacle.ground.barrel { border-radius: 6px; }
    .obstacle.ground.sign { position: relative; }
    .obstacle.ground.sign::before {
      /* ‡∏õ‡∏¥‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå ! ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏î‡∏π‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏µ‡∏°‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô */
      content: "";
    }
    .obstacle.ground.laser { }

    /* ‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡∏•‡∏≠‡∏¢ */
    .obstacle.air.bird { border-radius: 6px; }
    .obstacle.air.drone { border-radius: 40%; }
    .obstacle.air.fireball { border-radius: 50%; }

    /* =========================
       üî• ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ "‡∏ó‡∏∏‡∏Å‡∏ä‡∏¥‡πâ‡∏ô" ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô (‡πÑ‡∏ü: ‡πÅ‡∏î‡∏á-‡∏™‡πâ‡∏°-‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á)
       ========================= */
    :root{
      --flame-red: #ef4444;
      --flame-orange: #f97316;
      --flame-yellow: #facc15;
      --flame-glow: rgba(249,115,22,0.95);
      --flame-glow2: rgba(250,204,21,0.35);
    }

    .obstacle,
    .obstacle.ground,
    .obstacle.air,
    .obstacle.ground.tree,
    .obstacle.ground.bush,
    .obstacle.ground.rock,
    .obstacle.ground.spike,
    .obstacle.ground.crate,
    .obstacle.ground.barrel,
    .obstacle.ground.sign,
    .obstacle.ground.laser,
    .obstacle.air.bird,
    .obstacle.air.drone,
    .obstacle.air.fireball{
      background: linear-gradient(135deg, var(--flame-red), var(--flame-orange), var(--flame-yellow)) !important;
      border: 1px solid rgba(250,204,21,0.28) !important;
      box-shadow:
        0 0 16px var(--flame-glow),
        0 0 38px var(--flame-glow2),
        0 12px 24px rgba(0,0,0,0.25) !important;
    }

    /* ‡πÄ‡∏á‡∏≤‡πÑ‡∏ü‡πÄ‡∏•‡πá‡∏Å ‡πÜ ‡πÉ‡∏´‡πâ‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏õ‡∏•‡∏ß */
    .obstacle::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius: inherit;
      background: radial-gradient(circle at 30% 25%, rgba(250,204,21,0.35), transparent 60%);
      filter: blur(10px);
      opacity: 0.55;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    /* ‡∏û‡∏∑‡πâ‡∏ô‡∏•‡∏≠‡∏¢ */
    .platform {
      position: absolute;
      height: 10px;
      background: linear-gradient(to top, #020617, #111827);
      border-radius: 8px;
      box-shadow: 0 6px 14px rgba(15,23,42,0.95);
      border: 1px solid rgba(148,163,184,0.35);
      z-index: 2;
    }

    /* ‡∏´‡∏•‡∏∏‡∏° */
    .hole {
      position: absolute;
      bottom: 0;
      height: 40px;
      background: linear-gradient(to top, #000000 0%, #020617 55%);
      border-radius: 6px 6px 0 0;
      box-shadow:
        inset 0 0 24px rgba(0,0,0,0.9),
        0 -2px 0 rgba(148,163,184,0.6);
      z-index: 1;
      overflow: hidden;
    }
    .hole::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 14px;
      background:
        repeating-linear-gradient(
          -45deg,
          transparent 0 10px,
          #b91c1c 10px 20px
        );
      box-shadow: 0 -2px 8px rgba(248,113,113,0.8);
    }
    .hole::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: 2px;
      width: 60%;
      height: 10px;
      transform: translateX(-50%);
      background: radial-gradient(circle, rgba(248,113,113,0.7), transparent);
      opacity: 0.9;
    }

    /* ‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏° */
    .collectible {
      position: absolute;
      z-index: 4;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      line-height: 1;
      user-select: none;
      pointer-events: none;
      will-change: transform, opacity;
    }

    .collectible.coin {
      background: radial-gradient(circle at 30% 30%, #fef9c3, #facc15, #b45309);
      box-shadow: 0 0 12px rgba(250, 204, 21, 0.9);
    }
    .collectible.energy {
      background: radial-gradient(circle at 30% 20%, #fecaca, #ef4444, #b91c1c);
      box-shadow: 0 0 12px rgba(248, 113, 113, 0.95);
      font-size: 18px;
      transform: scale(1);
    }
    .collectible.energy.small  { transform: scale(0.85); }
    .collectible.energy.medium { transform: scale(1.0); }
    .collectible.energy.large  { transform: scale(1.25); }

    .collectible.magnet {
      background: radial-gradient(circle at 30% 20%, #e0f2fe, #38bdf8, #0369a1);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.95);
    }
    .collectible.boost {
      background: linear-gradient(90deg, #22c55e, #a3e635);
      box-shadow: 0 0 14px rgba(34, 197, 94, 0.95);
    }
    .collectible.giant {
      background: radial-gradient(circle at 30% 20%, #e0e7ff, #6366f1, #312e81);
      box-shadow: 0 0 14px rgba(129, 140, 248, 0.95);
    }

    /* Energy bar */
    #energyContainer {
      margin-top: 10px;
      width: 800px;
      max-width: 95vw;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }

    #energyLabel {
      font-size: 11px;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    #energyBarWrapper {
      flex: 1;
      height: 12px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #4b5563;
      overflow: hidden;
      box-shadow: 0 0 8px rgba(15,23,42,0.9);
    }

    #energyBar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #22c55e, #facc15, #fb923c);
      box-shadow: 0 0 12px rgba(250,204,21,0.8);
      transition: width 0.15s ease;
    }

    #energyText {
      width: 86px;
      text-align: right;
      font-size: 11px;
      color: #e5e7eb;
    }

    #scoreBoard {
      margin-top: 10px;
      font-size: 15px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    #coins { color: #facc15; }
    #coins small { color: #9ca3af; font-size: 11px; margin-left: 6px; }

    #cheatTimer {
      margin-top: 4px;
      font-size: 14px;
      min-height: 20px;
      color: #facc15;
      text-shadow: 0 0 8px rgba(250, 204, 21, 0.9);
    }

    #mission {
      margin-top: 6px;
      font-size: 12px;
      color: #9ca3af;
      max-width: 800px;
      text-align: center;
      padding: 0 12px;
    }

    #message {
      margin-top: 6px;
      font-size: 13px;
      color: #9ca3af;
      text-align: center;
      max-width: 800px;
      padding: 0 12px;
    }

    #itemGuide {
      margin-top: 8px;
      font-size: 12px;
      color: #e5e7eb;
      max-width: 800px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(148,163,184,0.45);
    }
    #itemGuide strong { color: #facc15; }
    #itemGuide ul { margin: 4px 0 0; padding-left: 18px; }
    #itemGuide li { margin-bottom: 2px; }

    #buttonsRow{
      margin-top: 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }

    #startBtn {
      padding: 8px 22px;
      border: none;
      border-radius: 999px;
      font-size: 14px;
      cursor: pointer;
      background: linear-gradient(to right, #22c55e, #2dd4bf);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(34, 197, 94, 0.35);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s;
    }
    #startBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 32px rgba(34, 197, 94, 0.55);
      filter: brightness(1.05);
    }
    #startBtn:active {
      transform: translateY(1px);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
      filter: brightness(0.98);
    }

    #fullscreenBtn{
      padding:8px 16px;
      border-radius:999px;
      border:1px solid #4b5563;
      background:radial-gradient(circle at 20% 0,#1f2937,#020617);
      color:#e5e7eb;
      font-size:13px;
      cursor:pointer;
      box-shadow:0 8px 18px rgba(15,23,42,0.9);
    }
    #fullscreenBtn:hover{
      border-color:#38bdf8;
      box-shadow:0 0 14px rgba(56,189,248,0.7);
    }
    #fullscreenBtn:active{
      transform:translateY(1px) scale(0.98);
      box-shadow:0 4px 10px rgba(15,23,42,0.9);
    }

    /* ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
    #touchControls {
      margin-top: 14px;
      width: 800px;
      max-width: 95vw;
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .ctrl-btn {
      flex: 1;
      padding: 12px 10px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: radial-gradient(circle at 20% 0, #1f2937, #020617);
      color: #e5e7eb;
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.04em;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(15,23,42,0.9);
      text-transform: uppercase;
    }
    .ctrl-btn span {
      font-size: 11px;
      display: block;
      opacity: 0.7;
      margin-top: 2px;
    }
    .ctrl-btn:hover {
      border-color: #38bdf8;
      box-shadow: 0 0 14px rgba(56,189,248,0.7);
    }
    .ctrl-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 4px 10px rgba(15,23,42,0.9);
    }

    /* === ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏™‡∏±‡πà‡∏ô‡∏à‡∏≠ / ‡πÅ‡∏ü‡∏•‡∏ä‡∏ï‡∏≠‡∏ô‡πÇ‡∏î‡∏ô‡∏ä‡∏ô === */
    @keyframes hitShake {
      0%   { transform: translate(0, 0); }
      20%  { transform: translate(-4px, 2px); }
      40%  { transform: translate(4px, -2px); }
      60%  { transform: translate(-3px, 1px); }
      80%  { transform: translate(3px, -1px); }
      100% { transform: translate(0, 0); }
    }
    #gameContainer.shake { animation: hitShake 0.25s ease; }

    #hitFlash {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, rgba(248,250,252,0.35), transparent 60%);
      mix-blend-mode: screen;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease;
      z-index: 999;
    }
    body.hit-blink #hitFlash { opacity: 1; }

    /* === GAME OVER MODAL === */
    #gameOverModal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 1200;
      background: rgba(2,6,23,0.72);
      backdrop-filter: blur(4px);
    }
    #gameOverModal.show { display: flex; }

    .modal-card {
      width: min(520px, 96vw);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.92);
      box-shadow: 0 24px 60px rgba(0,0,0,0.55);
      padding: 16px 16px 14px;
    }
    .modal-title {
      font-weight: 900;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: #facc15;
      text-shadow: 0 0 18px rgba(250,204,21,0.35);
      margin-bottom: 8px;
      font-size: 18px;
    }
    .modal-stats {
      color: #e5e7eb;
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 12px;
    }
    .modal-stats b { color: #facc15; }
    .modal-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }
    .modal-btn {
      width: 100%;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      cursor: pointer;
      font-weight: 800;
      letter-spacing: 0.03em;
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      transition: transform 0.08s ease, filter 0.12s ease, opacity 0.12s ease;
    }
    .modal-btn:hover { filter: brightness(1.05); transform: translateY(-1px); }
    .modal-btn:active { transform: translateY(1px); }

    #reviveBtn {
      background: linear-gradient(90deg, rgba(56,189,248,0.95), rgba(34,197,94,0.95));
      color: #02121a;
      border-color: rgba(56,189,248,0.55);
    }
    #restartBtn {
      background: linear-gradient(90deg, #22c55e, #2dd4bf);
      color: #022c22;
      border-color: rgba(34,197,94,0.55);
    }
    .modal-note {
      margin-top: 10px;
      font-size: 12px;
      color: #9ca3af;
      text-align: center;
    }

    @media (max-width: 600px) {
      #gameContainer { height: 230px; }
      #player { left: 40px; }

      #touchControls { margin-top: 12px; gap: 8px; }
      .ctrl-btn { padding: 10px 8px; font-size: 13px; }

      #energyContainer { font-size: 12px; }
      #energyText { width: 70px; font-size: 10px; }
    }
  </style>
</head>
<body>
  <h1>PHANToM Runner</h1>
  <div id="hint">
    Space / ‚Üë = ‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î (2 ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞) ‚Ä¢ ‚Üì = ‡∏´‡∏°‡∏≠‡∏ö ‚Ä¢ ‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏•‡∏≠‡∏¢/‡∏ö‡∏±‡∏ô‡πÑ‡∏î ‚Ä¢ ‡∏´‡∏•‡∏∏‡∏°‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å (‡∏ï‡∏Å‡πÑ‡∏î‡πâ ‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ) ‚Ä¢ ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç / ‡∏´‡∏±‡∏ß‡πÉ‡∏à / Magnet / Boost(‡∏≠‡∏°‡∏ï‡∏∞) / Giant
  </div>

  <div id="gameContainer">
    <div id="ground"></div>
    <div id="boostBeam"></div>

    <div id="player">
      <img src="phantom-runner.png" alt="PHANToM" />
    </div>
  </div>

  <div id="touchControls">
    <button id="btnJump" class="ctrl-btn">
      ‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î
      <span>JUMP / SPACE</span>
    </button>
    <button id="btnDuck" class="ctrl-btn">
      ‡∏´‡∏°‡∏≠‡∏ö
      <span>DUCK / ‚Üì</span>
    </button>
  </div>

  <div id="energyContainer">
    <div id="energyLabel">Energy</div>
    <div id="energyBarWrapper">
      <div id="energyBar"></div>
    </div>
    <div id="energyText">100 / 100</div>
  </div>

  <div id="scoreBoard">
    <div id="score">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: 0</div>
    <div id="coins">‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏™‡∏∞‡∏™‡∏°: 0 <small id="coinsRun">(‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ: 0)</small></div>
    <div id="bestScore">‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: 0</div>
  </div>

  <div id="cheatTimer"></div>
  <div id="mission"></div>
  <div id="message">‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà" ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î Space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°</div>

  <div id="itemGuide">
    <strong>‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°:</strong>
    <ul>
      <li>ü§ë <b>‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (Coin)</b> : +2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏™‡∏∞‡∏™‡∏°‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)</li>
      <li>‚ù§Ô∏è <b>‡∏´‡∏±‡∏ß‡πÉ‡∏à (Energy)</b> : ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Energy (‡πÉ‡∏´‡∏ç‡πà‡∏™‡∏∏‡∏î‡∏à‡∏∞‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏≠‡∏≠‡∏Å‡∏ó‡∏∏‡∏Å 40 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)</li>
      <li>üß≤ <b>Magnet</b> : ‡∏î‡∏π‡∏î‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏£‡∏≠‡∏ö ‡πÜ ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß</li>
      <li>‚ö° <b>Boost</b> : ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß</li>
      <li>üåÄ <b>Giant</b> : ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏£‡πà‡∏≤‡∏á ‡∏ä‡∏ô‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡∏û‡∏∑‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏û‡∏±‡∏á‡πÑ‡∏î‡πâ</li>
    </ul>
  </div>

  <div id="buttonsRow">
    <button id="startBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
    <button id="fullscreenBtn">‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</button>
  </div>

  <div id="hitFlash"></div>

  <!-- GAME OVER MODAL -->
  <div id="gameOverModal" aria-modal="true" role="dialog">
    <div class="modal-card">
      <div class="modal-title">Game Over</div>
      <div id="modalStats" class="modal-stats"></div>

      <div class="modal-actions">
        <button id="reviveBtn" class="modal-btn" style="display:none;">‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡∏î‡πâ‡∏ß‡∏¢ 20 ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç</button>
        <button id="restartBtn" class="modal-btn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
      </div>

      <div class="modal-note">‡∏Å‡∏î Space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ</div>
    </div>
  </div>

  <script>
    (function () {
      // =========================
      // üîß CONFIG ‡∏õ‡∏£‡∏±‡∏ö‡∏à‡∏π‡∏ô‡πÄ‡∏Å‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
      // =========================

      // ‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå
      const CFG_GRAVITY = 0.9;
      const CFG_JUMP_STRENGTH = 13.5;
      const CFG_MAX_JUMPS = 2;

      // Energy / Damage (‡∏•‡∏î‡∏•‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏î‡∏¥‡∏° 40%)
      const CFG_MAX_ENERGY = 100;
      const CFG_ENERGY_DECAY_PER_SEC = 4;
      const CFG_DAMAGE_GROUND = 15; // ‡πÄ‡∏î‡∏¥‡∏° 25
      const CFG_DAMAGE_AIR = 21;    // ‡πÄ‡∏î‡∏¥‡∏° 35

      // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
      const CFG_START_SPEED = 6;
      const CFG_SPEED_UP_EVERY_SCORE = 5;
      const CFG_SPEED_UP_AMOUNT = 0.5;
      const CFG_BOOST_MULTIPLIER = 1.6;

      // ‡∏ä‡∏∞‡∏•‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏î‡∏ô‡∏ä‡∏ô (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢)
      const CFG_HIT_SLOW_FACTOR = 0.8;   // ‡∏•‡∏î 20%
      const CFG_HIT_SLOW_DURATION = 500; // 0.5 ‡∏ß‡∏¥
      const CFG_HIT_IFRAMES = 350;       // ‡∏Å‡∏±‡∏ô‡πÇ‡∏î‡∏ô‡∏£‡∏±‡∏ß‡∏´‡∏•‡∏±‡∏á‡∏ä‡∏ô (ms)

      // ‡∏´‡∏•‡∏∏‡∏°
      const CFG_HOLE_CHANCE = 0.18;
      const CFG_TRAP_Y = -60;

      // Buff
      const CFG_CHEAT_INVINCIBLE_DURATION = 10000;
      const CFG_MAGNET_DURATION = 10000;
      const CFG_BOOST_DURATION = 5000;
      const CFG_GIANT_DURATION = 6000;

      // Magnet radius
      const CFG_MAGNET_RADIUS = 400; // ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ

      // ‡∏´‡∏±‡∏ß‡πÉ‡∏à
      const CFG_HEART_SMALL_GAIN = 15;
      const CFG_HEART_MEDIUM_GAIN = 25;
      const CFG_HEART_LARGE_GAIN = 40;

      // ‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à
      const CFG_MISSION_COIN_TARGET = 20;
      const CFG_MISSION_DJ_TARGET = 10;
      const CFG_MISSION_OBS_TARGET = 30;

      // Spawner ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô 2 ‡∏™‡∏≤‡∏¢ + ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏∏‡∏Å 40 ‡∏ß‡∏¥
      const CFG_COIN_BASE_INTERVAL = 520;
      const CFG_COIN_MIN_INTERVAL  = 250;
      const CFG_SPECIAL_BASE_INTERVAL = 1200;
      const CFG_SPECIAL_MIN_INTERVAL  = 650;
      const CFG_BIG_HEART_EVERY_MS = 40000;

      // ‡∏™‡∏π‡∏ï‡∏£‡πÇ‡∏Å‡∏á
      const CFG_CHEAT_WINDOW = 1000;

      // Game Over / Revive
      const CFG_REVIVE_COST = 20;
      const CFG_REVIVE_ENERGY = 55;
      const CFG_REVIVE_INVINCIBLE_MS = 1200;

      // localStorage keys
      const LS_BEST = "phantom_runner_best";
      const LS_WALLET = "phantom_runner_wallet_coins";

      // ==========
      // DOM
      // ==========
      const gameContainer = document.getElementById("gameContainer");
      const player = document.getElementById("player");
      const scoreEl = document.getElementById("score");
      const bestScoreEl = document.getElementById("bestScore");
      const messageEl = document.getElementById("message");
      const startBtn = document.getElementById("startBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const cheatTimerEl = document.getElementById("cheatTimer");
      const btnJump = document.getElementById("btnJump");
      const btnDuck = document.getElementById("btnDuck");
      const energyBar = document.getElementById("energyBar");
      const energyText = document.getElementById("energyText");
      const coinsEl = document.getElementById("coins");
      const coinsRunEl = document.getElementById("coinsRun");
      const missionEl = document.getElementById("mission");
      const boostBeam = document.getElementById("boostBeam");

      const gameOverModal = document.getElementById("gameOverModal");
      const modalStats = document.getElementById("modalStats");
      const reviveBtn = document.getElementById("reviveBtn");
      const restartBtn = document.getElementById("restartBtn");

      const groundY = 40;

      // ==========
      // State
      // ==========
      const gravity = CFG_GRAVITY;
      const jumpStrength = CFG_JUMP_STRENGTH;
      const maxJumps = CFG_MAX_JUMPS;

      let playerY = groundY;
      let prevPlayerY = groundY;
      let jumpVelocity = 0;
      let jumpsLeft = maxJumps;

      let isDucking = false;

      const maxEnergy = CFG_MAX_ENERGY;
      let energy = maxEnergy;

      let score = 0;
      let bestScore = Number(localStorage.getItem(LS_BEST) || 0);

      // ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: ‡πÅ‡∏¢‡∏Å "‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ" ‡∏Å‡∏±‡∏ö "‡∏™‡∏∞‡∏™‡∏°"
      let runCoins = 0;
      let walletCoins = Number(localStorage.getItem(LS_WALLET) || 0);

      // Mission
      let coinsCollected = 0;
      let totalDoubleJumps = 0;
      let obstaclesPassed = 0;

      const MISSION_COIN_TARGET = CFG_MISSION_COIN_TARGET;
      const MISSION_DJ_TARGET = CFG_MISSION_DJ_TARGET;
      const MISSION_OBS_TARGET = CFG_MISSION_OBS_TARGET;

      let obstacles = [];
      let collectibles = [];
      let platforms = [];
      let holes = [];

      let speed = CFG_START_SPEED;

      let gameOver = false;
      let frameId = null;
      let lastTime = null;

      let timeSinceLastObstacle = 0;
      let nextSpawnIn = 1000;

      // Spawner ‡πÅ‡∏¢‡∏Å
      let timeSinceLastCoin = 0;
      let timeSinceLastSpecial = 0;
      let timeSinceLastBigHeart = 0;

      let timeSinceLastPlatform = 0;
      let nextPlatformIn = 2000 + Math.random() * (4500 - 2000);

      // Invincible
      let invincible = false;
      let invincibleTimer = 0;

      // Power-ups
      let magnetActive = false;
      let magnetTimer = 0;

      let boostActive = false;
      let boostTimer = 0;

      let giantActive = false;
      let giantTimer = 0;

      // Slow + i-frames ‡∏´‡∏•‡∏±‡∏á‡∏ä‡∏ô
      let hitSlowTimer = 0;
      let hitIFramesTimer = 0;

      // Cheat
      let cheatEvents = [];

      // Revive ‡∏ï‡πà‡∏≠ 1 ‡∏£‡∏≠‡∏ö
      let revivedThisRun = false;

      // ==========
      // Helpers
      // ==========
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function randomBetween(min, max) { return Math.random() * (max - min) + min; }

      function saveWallet() {
        localStorage.setItem(LS_WALLET, String(walletCoins));
      }

      function updateCoinsUI(){
        coinsEl.firstChild && (coinsEl.firstChild.textContent = "");
        coinsEl.textContent = "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏™‡∏∞‡∏™‡∏°: " + walletCoins + " ";
        if (coinsRunEl) coinsRunEl.textContent = "(‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ: " + runCoins + ")";
        coinsEl.appendChild(coinsRunEl);
      }

      function updateEnergyUI() {
        const ratio = clamp(energy / maxEnergy, 0, 1);
        energyBar.style.width = (ratio * 100) + "%";
        energyText.textContent = Math.round(energy) + " / " + maxEnergy;
      }

      function updateMissionUI() {
        if (!missionEl) return;
        missionEl.textContent =
          "Mission: ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç " + coinsCollected + "/" + MISSION_COIN_TARGET +
          " ‚Ä¢ Double Jump " + totalDoubleJumps + "/" + MISSION_DJ_TARGET +
          " ‚Ä¢ ‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ " + obstaclesPassed + "/" + MISSION_OBS_TARGET;
      }

      function hideGameOverModal(){
        if (!gameOverModal) return;
        gameOverModal.classList.remove("show");
      }

      function showGameOverModal(){
        if (!gameOverModal || !modalStats) return;

        const canRevive = (!revivedThisRun && walletCoins >= CFG_REVIVE_COST);
        if (reviveBtn){
          reviveBtn.style.display = canRevive ? "block" : "none";
          reviveBtn.textContent = canRevive
            ? ("‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡∏î‡πâ‡∏ß‡∏¢ " + CFG_REVIVE_COST + " ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠: " + walletCoins + ")")
            : "";
        }

        modalStats.innerHTML =
          "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <b>" + score + "</b><br/>" +
          "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ: <b>" + runCoins + "</b><br/>" +
          "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏™‡∏∞‡∏™‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <b>" + walletCoins + "</b><br/>" +
          "Energy ‡πÄ‡∏´‡∏•‡∏∑‡∏≠: <b>" + Math.round(energy) + "</b>";

        gameOverModal.classList.add("show");
      }

      function clearArrays() {
        obstacles.forEach(o => o && o.remove());
        obstacles = [];
        collectibles.forEach(c => c && c.remove());
        collectibles = [];
        platforms.forEach(p => p && p.remove());
        platforms = [];
        holes.forEach(h => h && h.remove());
        holes = [];
      }

      function resetGame() {
        hideGameOverModal();
        clearArrays();

        score = 0;
        runCoins = 0;
        coinsCollected = 0;
        totalDoubleJumps = 0;
        obstaclesPassed = 0;
        speed = CFG_START_SPEED;

        scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;

        gameOver = false;
        revivedThisRun = false;

        isDucking = false;
        playerY = groundY;
        prevPlayerY = groundY;
        jumpVelocity = 0;
        jumpsLeft = maxJumps;
        player.style.bottom = playerY + "px";
        player.classList.remove("duck", "invincible", "giant", "double-jump");

        invincible = false;
        invincibleTimer = 0;
        cheatEvents = [];
        cheatTimerEl.textContent = "";

        magnetActive = false; magnetTimer = 0;
        boostActive = false;  boostTimer = 0;
        giantActive = false;  giantTimer = 0;

        hitSlowTimer = 0;
        hitIFramesTimer = 0;

        energy = maxEnergy;
        updateEnergyUI();

        timeSinceLastObstacle = 0;
        nextSpawnIn = 800 + Math.random() * 600;

        timeSinceLastCoin = 0;
        timeSinceLastSpecial = 0;
        timeSinceLastBigHeart = 0;

        timeSinceLastPlatform = 0;
        nextPlatformIn = 2000 + Math.random() * (4500 - 2000);

        updateCoinsUI();
        updateMissionUI();

        messageEl.textContent = "‡∏´‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏∏‡∏°‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!";

        if (boostBeam) {
          boostBeam.style.opacity = 0;
          boostBeam.style.left = "-9999px";
        }

        if (frameId) cancelAnimationFrame(frameId);
        lastTime = null;
        frameId = requestAnimationFrame(gameLoop);

        spawnObstacle();
      }

      // ==============
      // Spawners
      // ==============
      function spawnHole() {
        const h = document.createElement("div");
        h.classList.add("hole");
        const width = randomBetween(80, 160);
        h.style.width = width + "px";
        h.style.left = gameContainer.offsetWidth + "px";
        h.style.bottom = "0px";
        gameContainer.appendChild(h);
        holes.push(h);
      }

      function spawnObstacle() {
        const isAir = Math.random() < 0.35;

        if (!isAir && Math.random() < CFG_HOLE_CHANCE) {
          spawnHole();
          return;
        }

        const obs = document.createElement("div");
        obs.classList.add("obstacle");

        if (isAir) {
          const airTypes = ["bird", "drone", "fireball"];
          const kind = airTypes[Math.floor(Math.random() * airTypes.length)];
          obs.classList.add("air", kind);

          const height = randomBetween(24, 32);
          const width = randomBetween(34, 40);
          obs.style.width = width + "px";
          obs.style.height = height + "px";
          obs.style.bottom = randomBetween(95, 125) + "px";
        } else {
          obs.classList.add("ground");

          // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡πÉ‡∏´‡∏°‡πà: "low" (‡πÄ‡∏ï‡∏µ‡πâ‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏° ~30-40%) ‡∏¢‡∏±‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡∏´‡∏•‡∏ö
          const groundTypes = ["tree", "bush", "rock", "spike", "crate", "barrel", "sign", "laser", "low"];
          const kind = groundTypes[Math.floor(Math.random() * groundTypes.length)];
          obs.classList.add(kind);

          let height, width;

          if (kind === "low") {
            // ‡πÄ‡∏î‡∏¥‡∏° 45-80 ‚Üí ‡∏•‡∏î‡∏•‡∏á ~30-40% => ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 28-55
            height = randomBetween(28, 52);
            width  = randomBetween(28, 48); // ‡πÉ‡∏´‡πâ‡∏î‡∏π‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡πÄ‡∏ï‡∏µ‡πâ‡∏¢ ‡πÜ
            obs.style.borderRadius = "14px";
          } else {
            height = randomBetween(45, 80);
            width  = randomBetween(22, 40);
          }

          obs.style.width = width + "px";
          obs.style.height = height + "px";
          obs.style.bottom = groundY + "px";
        }

        obs.style.left = gameContainer.offsetWidth + "px";
        gameContainer.appendChild(obs);
        obstacles.push(obs);
      }

      function spawnPlatformGroup() {
        const num = Math.random() < 0.5 ? 2 : 3;
        const baseBottom = groundY + randomBetween(45, 130);
        const step = 24;
        const goingUp = Math.random() < 0.5;
        const baseLeft = gameContainer.offsetWidth + 80;

        for (let i = 0; i < num; i++) {
          const p = document.createElement("div");
          p.classList.add("platform");
          const width = randomBetween(80, 150);
          const spacing = 20;

          p.style.width = width + "px";
          p.style.left = (baseLeft + i * (width + spacing)) + "px";
          p.style.bottom = (baseBottom + (goingUp ? i : -i) * step) + "px";

          gameContainer.appendChild(p);
          platforms.push(p);
        }
      }

      function makeCollectibleBase() {
        const c = document.createElement("div");
        c.classList.add("collectible");
        c.dataset.dead = "0";
        c.dataset.pulled = "0";
        return c;
      }

      function setCollectibleLane(c) {
        const lane = Math.floor(Math.random() * 3);
        let bottom;
        if (lane === 0) bottom = groundY + 60;
        else if (lane === 1) bottom = groundY + 110;
        else bottom = groundY + 150;
        c.style.bottom = bottom + "px";
        c.style.left = gameContainer.offsetWidth + "px";
      }

      function spawnCoin() {
        const c = makeCollectibleBase();
        c.classList.add("coin");
        c.textContent = "ü§ë";
        setCollectibleLane(c);
        gameContainer.appendChild(c);
        collectibles.push(c);
      }

      function spawnLargeHeartForced() {
        const c = makeCollectibleBase();
        c.classList.add("energy", "large");
        c.dataset.energy = String(CFG_HEART_LARGE_GAIN);
        c.textContent = "‚ù§Ô∏è";
        setCollectibleLane(c);
        gameContainer.appendChild(c);
        collectibles.push(c);
      }

      function spawnSpecial() {
        const r = Math.random();
        const c = makeCollectibleBase();

        if (r < 0.333) {
          c.classList.add("energy");
          const sizes = ["small","medium"];
          const gains = [CFG_HEART_SMALL_GAIN, CFG_HEART_MEDIUM_GAIN];
          const idx = Math.floor(Math.random() * sizes.length);
          c.classList.add(sizes[idx]);
          c.dataset.energy = String(gains[idx]);
          c.textContent = "‚ù§Ô∏è";
        } else if (r < 0.666) {
          c.classList.add("magnet");
          c.textContent = "üß≤";
        } else if (r < 0.844) {
          c.classList.add("boost");
          c.textContent = "‚ö°";
        } else {
          c.classList.add("giant");
          c.textContent = "üåÄ";
        }

        setCollectibleLane(c);
        gameContainer.appendChild(c);
        collectibles.push(c);
      }

      // ==============
      // Speed + VFX
      // ==============
      function getEffectiveSpeed() {
        let s = speed;
        if (boostActive) s *= CFG_BOOST_MULTIPLIER;
        if (hitSlowTimer > 0) s *= CFG_HIT_SLOW_FACTOR;
        return s;
      }

      function triggerHitVFX() {
        gameContainer.classList.remove("shake");
        void gameContainer.offsetWidth;
        gameContainer.classList.add("shake");

        document.body.classList.add("hit-blink");
        setTimeout(() => document.body.classList.remove("hit-blink"), 120);
      }

      function pullCollectibleToPlayer(c) {
        if (!c || c.dataset.pulled === "1" || c.dataset.dead === "1") return;
        c.dataset.pulled = "1";

        const pr = player.getBoundingClientRect();
        const cr = c.getBoundingClientRect();

        const targetX = pr.left + pr.width / 2;
        const targetY = pr.top + pr.height / 2;
        const cx = cr.left + cr.width / 2;
        const cy = cr.top + cr.height / 2;

        const dx = targetX - cx;
        const dy = targetY - cy;

        c.style.transition = "transform 0.2s linear, opacity 0.2s linear";
        c.style.transform = "translate(" + dx + "px," + dy + "px) scale(0.8)";
        c.style.opacity = "0.15";

        setTimeout(() => {
          if (!c || c.dataset.dead === "1") return;
          applyCollectibleEffect(c);
          c.dataset.dead = "1";
          c.remove();
        }, 190);
      }

      function applyCollectibleEffect(c) {
        if (!c) return;

        if (c.classList.contains("coin")) {
          runCoins += 1;
          walletCoins += 1;
          saveWallet();

          coinsCollected += 1;
          score += 2;

          scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
          updateCoinsUI();
        }
        else if (c.classList.contains("energy")) {
          const gain = parseInt(c.dataset.energy || "20", 10);
          energy = Math.min(maxEnergy, energy + gain);
          updateEnergyUI();
        }
        else if (c.classList.contains("magnet")) {
          magnetActive = true;
          magnetTimer = CFG_MAGNET_DURATION;
          messageEl.textContent = "Magnet: ‡∏î‡∏π‡∏î‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏£‡∏≠‡∏ö ‡πÜ ‚ú®";
        }
        else if (c.classList.contains("boost")) {
          boostActive = true;
          boostTimer = CFG_BOOST_DURATION;

          invincible = true;
          invincibleTimer = Math.max(invincibleTimer, CFG_BOOST_DURATION);

          player.classList.add("invincible");
          cheatTimerEl.textContent = "Boost: ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‚ö°";
          messageEl.textContent = "Boost: ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‚ö°";
        }
        else if (c.classList.contains("giant")) {
          giantActive = true;
          giantTimer = CFG_GIANT_DURATION;
          player.classList.add("giant");
          messageEl.textContent = "Giant: PHANToM ‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏ç‡πà ‡∏ä‡∏ô‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡∏û‡∏∑‡πâ‡∏ô‡∏û‡∏±‡∏á‡πÑ‡∏î‡πâ üí•";
        }

        updateMissionUI();
      }

      function isColliding(a, b) {
        const r1 = a.getBoundingClientRect();
        const r2 = b.getBoundingClientRect();
        return !(
          r1.right < r2.left ||
          r1.left > r2.right ||
          r1.bottom < r2.top ||
          r1.top > r2.bottom
        );
      }

      // ==============
      // Updates
      // ==============
      function updateObstacles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);

        obstacles = obstacles.filter(obs => {
          if (!obs || !obs.isConnected) return false;

          const left = parseFloat(obs.style.left);
          const newLeft = left - moveX;
          obs.style.left = newLeft + "px";

          if (newLeft + obs.offsetWidth < 0) {
            obs.remove();

            score += 1;
            obstaclesPassed += 1;
            scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
            updateMissionUI();

            if (CFG_SPEED_UP_EVERY_SCORE > 0 && score % CFG_SPEED_UP_EVERY_SCORE === 0) {
              speed += CFG_SPEED_UP_AMOUNT;
            }
            return false;
          }

          if (!gameOver && isColliding(player, obs)) {
            if (invincible || giantActive) {
              score += 2;
              obstaclesPassed += 1;
              scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
              updateMissionUI();

              obs.remove();
              return false;
            } else {
              if (hitIFramesTimer > 0) return true;

              const isAir = obs.classList.contains("air");
              const dmg = isAir ? CFG_DAMAGE_AIR : CFG_DAMAGE_GROUND;

              energy -= dmg;
              if (energy <= 0) {
                energy = 0;
                updateEnergyUI();
                endGame();
                return true;
              }

              updateEnergyUI();

              triggerHitVFX();
              hitSlowTimer = CFG_HIT_SLOW_DURATION;
              hitIFramesTimer = CFG_HIT_IFRAMES;

              obs.style.opacity = "0.4";
              setTimeout(() => { if (obs && obs.style) obs.style.opacity = "1"; }, 100);
            }
          }

          return true;
        });

        timeSinceLastObstacle += delta;

        const minInterval = Math.max(550, 1000 - score * 5);
        const maxInterval = Math.max(minInterval + 300, 1600 - score * 8);

        if (timeSinceLastObstacle >= nextSpawnIn) {
          let canSpawn = true;

          if (obstacles.length > 0) {
            const lastObs = obstacles[obstacles.length - 1];
            const lastRect = lastObs.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            const distance = containerRect.right - lastRect.right;
            if (distance < 180) canSpawn = false;
          }

          if (canSpawn) {
            spawnObstacle();
            timeSinceLastObstacle = 0;
            nextSpawnIn = randomBetween(minInterval, maxInterval);
          } else {
            timeSinceLastObstacle = minInterval - 50;
          }
        }
      }

      function updatePlatforms(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        platforms = platforms.filter(p => {
          if (!p || !p.isConnected) return false;
          const left = parseFloat(p.style.left);
          const newLeft = left - moveX;
          p.style.left = newLeft + "px";
          if (newLeft + p.offsetWidth < 0) {
            p.remove();
            return false;
          }
          return true;
        });

        timeSinceLastPlatform += delta;
        if (timeSinceLastPlatform >= nextPlatformIn) {
          if (platforms.length < 10) spawnPlatformGroup();
          timeSinceLastPlatform = 0;
          nextPlatformIn = 2000 + Math.random() * (4500 - 2000);
        }
      }

      function updateHoles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        holes = holes.filter(h => {
          if (!h || !h.isConnected) return false;
          const left = parseFloat(h.style.left);
          const newLeft = left - moveX;
          h.style.left = newLeft + "px";
          if (newLeft + h.offsetWidth < 0) {
            h.remove();
            return false;
          }
          return true;
        });
      }

      function updateCollectibles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);

        let playerCenterX = 0;
        let playerCenterY = 0;
        if (magnetActive) {
          const pr = player.getBoundingClientRect();
          playerCenterX = pr.left + pr.width / 2;
          playerCenterY = pr.top + pr.height / 2;
        }

        collectibles.forEach(c => {
          if (!c || c.dataset.dead === "1") return;

          if (c.dataset.pulled === "1") return;

          const left = parseFloat(c.style.left);
          const newLeft = left - moveX;
          c.style.left = newLeft + "px";

          if (newLeft + c.offsetWidth < 0) {
            c.dataset.dead = "1";
            c.remove();
            return;
          }

          if (
            magnetActive &&
            (c.classList.contains("coin") || c.classList.contains("energy"))
          ) {
            const cr = c.getBoundingClientRect();
            const cx = cr.left + cr.width / 2;
            const cy = cr.top + cr.height / 2;
            const dist = Math.hypot(playerCenterX - cx, playerCenterY - cy);

            if (dist < CFG_MAGNET_RADIUS) {
              pullCollectibleToPlayer(c);
              return;
            }
          }

          if (!gameOver && isColliding(player, c)) {
            applyCollectibleEffect(c);
            c.dataset.dead = "1";
            c.remove();
          }
        });

        collectibles = collectibles.filter(c => c && c.isConnected && c.dataset.dead !== "1");
      }

      function updatePlayer(delta) {
        const factor = delta / 16.67;
        prevPlayerY = playerY;

        jumpVelocity -= gravity * factor;
        playerY += jumpVelocity * factor;

        let supportY = groundY;
        const isFalling = jumpVelocity <= 0;

        const playerRect = player.getBoundingClientRect();
        const playerLeftScreen = playerRect.left;
        const playerRightScreen = playerRect.right;

        const playerStyleLeft = parseFloat(getComputedStyle(player).left);
        const playerStyleRight = playerStyleLeft + player.offsetWidth;

        platforms.forEach(p => {
          if (!p || !p.isConnected) return;
          const pRect = p.getBoundingClientRect();
          const pLeft = pRect.left;
          const pRight = pRect.right;

          const platformBottom = parseFloat(p.style.bottom);
          const platformTop = platformBottom + p.offsetHeight;

          const horizontallyOver = (playerRightScreen > pLeft + 5) && (playerLeftScreen < pRight - 5);
          if (horizontallyOver && isFalling && prevPlayerY >= platformTop && playerY <= platformTop) {
            if (platformTop > supportY) supportY = platformTop;
          }
        });

        let holeUnder = false;
        holes.forEach(h => {
          if (!h || !h.isConnected) return;
          const hLeft = parseFloat(h.style.left);
          const hRight = hLeft + h.offsetWidth;
          if (hRight > playerStyleLeft + 5 && hLeft < playerStyleRight - 5) holeUnder = true;
        });

        if (playerY <= supportY) {
          if (!(supportY === groundY && holeUnder)) {
            playerY = supportY;
            jumpVelocity = 0;
            jumpsLeft = maxJumps;
          }
        }

        player.style.bottom = playerY + "px";

        if (boostBeam) {
          if (boostActive) {
            const baseLeft = parseFloat(getComputedStyle(player).left) || 80;
            boostBeam.style.opacity = 1;
            boostBeam.style.left = (baseLeft - 90) + "px";
            boostBeam.style.bottom = (playerY + 8) + "px";
          } else if (boostBeam.style.opacity !== "0") {
            boostBeam.style.opacity = 0;
          }
        }
      }

      function checkHoleTrap() {
        if (playerY < CFG_TRAP_Y) endGame();
      }

      function updateSpawners(delta){
        timeSinceLastCoin += delta;
        const coinInterval = Math.max(
          CFG_COIN_MIN_INTERVAL,
          CFG_COIN_BASE_INTERVAL - score * 2
        );
        if (timeSinceLastCoin >= coinInterval) {
          spawnCoin();
          timeSinceLastCoin = 0;
        }

        timeSinceLastSpecial += delta;
        const specialInterval = Math.max(
          CFG_SPECIAL_MIN_INTERVAL,
          CFG_SPECIAL_BASE_INTERVAL - Math.floor(score / 3) * 10
        );
        if (timeSinceLastSpecial >= specialInterval) {
          spawnSpecial();
          timeSinceLastSpecial = 0;
        }

        timeSinceLastBigHeart += delta;
        if (timeSinceLastBigHeart >= CFG_BIG_HEART_EVERY_MS) {
          spawnLargeHeartForced();
          timeSinceLastBigHeart = 0;
        }
      }

      function gameLoop(timestamp) {
        if (gameOver) return;
        if (!lastTime) lastTime = timestamp;
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        if (!invincible) {
          energy -= CFG_ENERGY_DECAY_PER_SEC * (delta / 1000);
          if (energy <= 0) {
            energy = 0;
            updateEnergyUI();
            endGame();
            return;
          }
        }
        updateEnergyUI();

        updatePlayer(delta);
        updatePlatforms(delta);
        updateHoles(delta);
        checkHoleTrap();
        if (gameOver) return;

        updateObstacles(delta);
        updateCollectibles(delta);

        updateSpawners(delta);

        if (invincible) {
          invincibleTimer -= delta;
          if (invincibleTimer <= 0) {
            invincible = false;
            player.classList.remove("invincible");
            cheatTimerEl.textContent = "";
            if (!boostActive) messageEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß! ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÉ‡∏´‡πâ‡∏î‡∏µ üòà";
          } else if (invincibleTimer <= 3000) {
            cheatTimerEl.textContent = "‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞: " + Math.ceil(invincibleTimer / 1000) + " ‡∏ß‡∏¥";
          }
        }

        if (magnetActive) {
          magnetTimer -= delta;
          if (magnetTimer <= 0) magnetActive = false;
        }

        if (boostActive) {
          boostTimer -= delta;
          if (boostTimer <= 0) boostActive = false;
        }

        if (giantActive) {
          giantTimer -= delta;
          if (giantTimer <= 0) {
            giantActive = false;
            player.classList.remove("giant");
          }
        }

        if (hitSlowTimer > 0) {
          hitSlowTimer -= delta;
          if (hitSlowTimer < 0) hitSlowTimer = 0;
        }

        if (hitIFramesTimer > 0) {
          hitIFramesTimer -= delta;
          if (hitIFramesTimer < 0) hitIFramesTimer = 0;
        }

        frameId = requestAnimationFrame(gameLoop);
      }

      function endGame() {
        if (gameOver) return;
        gameOver = true;
        if (frameId) cancelAnimationFrame(frameId);

        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem(LS_BEST, String(bestScore));
        }
        bestScoreEl.textContent = "‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: " + bestScore;

        messageEl.textContent =
          "Game Over! ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score +
          " ‚Ä¢ ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ: " + runCoins +
          " ‚Ä¢ ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏™‡∏∞‡∏™‡∏°: " + walletCoins +
          ' ‚Ä¢ ‡∏Å‡∏î "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà" ‡∏´‡∏£‡∏∑‡∏≠ Space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà';

        if (boostBeam) boostBeam.style.opacity = 0;

        showGameOverModal();
      }

      // ==========
      // Controls
      // ==========
      function handleJump() {
        if (gameOver) {
          resetGame();
          return;
        }

        if (jumpsLeft > 0) {
          if (isDucking) setDuck(false);

          if (jumpsLeft === 1) {
            totalDoubleJumps += 1;
            updateMissionUI();

            player.classList.remove("double-jump");
            void player.offsetWidth;
            player.classList.add("double-jump");
          }

          jumpVelocity = jumpStrength;
          jumpsLeft -= 1;
        }
      }

      function setDuck(state) {
        if (gameOver) return;
        if (state && !isDucking) {
          isDucking = true;
          player.classList.add("duck");
        } else if (!state && isDucking) {
          isDucking = false;
          player.classList.remove("duck");
        }
      }

      function registerCheat(code) {
        const now = performance.now();
        if (code !== "ArrowDown" && code !== "ArrowUp" && code !== "Space") return;

        const symbol = (code === "ArrowDown") ? "D" : "U";
        cheatEvents.push({ symbol, time: now });

        const cutoff = now - CFG_CHEAT_WINDOW;
        cheatEvents = cheatEvents.filter(e => e.time >= cutoff);

        const lastSix = cheatEvents.slice(-6);
        if (lastSix.length === 6) {
          const pattern = lastSix.map(e => e.symbol).join("");
          if (pattern === "DDDUUU" && !gameOver) {
            activateCheat();
            cheatEvents = [];
          }
        }
      }

      function activateCheat() {
        invincible = true;
        invincibleTimer = Math.max(invincibleTimer, CFG_CHEAT_INVINCIBLE_DURATION);
        player.classList.add("invincible");
        cheatTimerEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á: PHANToM ‡∏≠‡∏°‡∏ï‡∏∞ 10 ‡∏ß‡∏¥ üéÉ";
        messageEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß! ‡∏ä‡∏ô‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢ 10 ‡∏ß‡∏¥";
      }

      function toggleFullscreen(){
        const elem = document.documentElement;
        if (!document.fullscreenElement){
          if (elem.requestFullscreen) elem.requestFullscreen();
          else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
          else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          else if (document.msExitFullscreen) document.msRequestFullscreen();
        }
      }

      if (fullscreenBtn){
        fullscreenBtn.addEventListener("click",(e)=>{
          e.preventDefault();
          toggleFullscreen();
        });
      }

      document.addEventListener("fullscreenchange", () => {
        if (!fullscreenBtn) return;
        if (document.fullscreenElement){
          fullscreenBtn.textContent = "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠";
          document.body.classList.add("fullscreen-game");
        } else {
          fullscreenBtn.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠";
          document.body.classList.remove("fullscreen-game");
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          handleJump();
          registerCheat(e.code);
        } else if (e.code === "ArrowDown") {
          e.preventDefault();
          setDuck(true);
          registerCheat(e.code);
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "ArrowDown") setDuck(false);
      });

      if (btnJump) {
        btnJump.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          handleJump();
          registerCheat("Space");
        });
      }

      if (btnDuck) {
        btnDuck.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          setDuck(true);
          registerCheat("ArrowDown");
        });
        btnDuck.addEventListener("pointerup",   (e) => { e.preventDefault(); setDuck(false); });
        btnDuck.addEventListener("pointercancel",(e)=> { e.preventDefault(); setDuck(false); });
        btnDuck.addEventListener("pointerleave", () => { if (isDucking) setDuck(false); });
      }

      if (startBtn) startBtn.addEventListener("click", resetGame);
      if (restartBtn) restartBtn.addEventListener("click", resetGame);

      function reviveNow(){
        if (!gameOver) return;
        if (revivedThisRun) return;
        if (walletCoins < CFG_REVIVE_COST) return;

        walletCoins -= CFG_REVIVE_COST;
        saveWallet();
        updateCoinsUI();

        revivedThisRun = true;
        hideGameOverModal();

        gameOver = false;
        lastTime = null;

        clearArrays();

        energy = clamp(CFG_REVIVE_ENERGY, 1, maxEnergy);
        updateEnergyUI();

        invincible = true;
        invincibleTimer = Math.max(invincibleTimer, CFG_REVIVE_INVINCIBLE_MS);
        player.classList.add("invincible");

        hitSlowTimer = 0;
        hitIFramesTimer = CFG_HIT_IFRAMES;

        playerY = groundY;
        prevPlayerY = groundY;
        jumpVelocity = 0;
        jumpsLeft = maxJumps;
        player.style.bottom = playerY + "px";

        messageEl.textContent = "‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡πÅ‡∏•‡πâ‡∏ß! ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏ï‡πà‡∏≠‡∏≠‡∏µ‡∏Å‡∏ô‡∏¥‡∏î üî•";
        cheatTimerEl.textContent = "Revive: ‡∏≠‡∏°‡∏ï‡∏∞‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏¢‡∏ã‡πâ‡∏≥ " + Math.ceil(CFG_REVIVE_INVINCIBLE_MS/1000) + " ‡∏ß‡∏¥";

        timeSinceLastObstacle = 0;
        nextSpawnIn = 650 + Math.random() * 500;
        timeSinceLastCoin = 0;
        timeSinceLastSpecial = 0;

        frameId = requestAnimationFrame(gameLoop);
        spawnObstacle();
      }

      if (reviveBtn) reviveBtn.addEventListener("click", reviveNow);

      // Init
      bestScoreEl.textContent = "‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: " + bestScore;
      updateCoinsUI();
      updateEnergyUI();
      updateMissionUI();
    })();
  </script>
</body>
</html>
