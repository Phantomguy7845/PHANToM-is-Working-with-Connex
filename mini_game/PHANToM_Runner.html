<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <title>PHANToM Runner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 40px;
    }

    body.fullscreen-game{
      padding-top: 12px;
    }

    h1 {
      margin-bottom: 8px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    #hint {
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 12px;
      text-align: center;
    }

    #gameContainer {
      position: relative;
      width: 800px;
      max-width: 95vw;
      height: 260px;
      border: 2px solid #4b5563;
      overflow: hidden;
      border-radius: 16px;
      background: radial-gradient(circle at top, #1d2337 0, #020617 55%, #020617 100%);
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.9);
    }

    #ground {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 200%;
      height: 40px;
      background: repeating-linear-gradient(
        -45deg,
        #6b7280 0,
        #6b7280 12px,
        #4b5563 12px,
        #4b5563 24px
      );
      animation: groundMove 1s linear infinite;
      opacity: 0.9;
      z-index: 1;
    }

    @keyframes groundMove {
      from { transform: translateX(0); }
      to   { transform: translateX(-50%); }
    }

    /* ==== ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ==== */
    #player {
      position: absolute;
      bottom: 40px;
      left: 80px;
      width: 60px;
      height: 60px;
      transform-origin: center bottom;
      transition: transform 0.08s ease, width 0.12s ease, height 0.12s ease;
      box-shadow: none;
      z-index: 5;
    }

    #player img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      background: transparent;
      filter: drop-shadow(0 0 16px rgba(56,189,248,0.8));
    }

    /* ‡∏´‡∏°‡∏≠‡∏ö */
    #player.duck {
      transform: translateY(-8px) scaleY(0.5);
    }
    #player.duck img {
      filter: drop-shadow(0 0 14px rgba(56,189,248,0.9));
    }

    /* ‡∏≠‡∏°‡∏ï‡∏∞ (‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á / Boost) */
    #player.invincible img {
      filter:
        drop-shadow(0 0 26px rgba(250,204,21,1))
        drop-shadow(0 0 70px rgba(250,204,21,0.7));
    }

    /* ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏£‡πà‡∏≤‡∏á (Giant) */
    #player.giant {
      width: 130px;
      height: 130px;
    }
    #player.giant img {
      filter:
        drop-shadow(0 0 26px rgba(59,130,246,1))
        drop-shadow(0 0 70px rgba(59,130,246,0.7));
    }

    /* ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå double jump: ‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏±‡∏ß */
    #player.double-jump img {
      animation: djumpSpin 0.2s linear;
    }

    @keyframes djumpSpin {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    /* ‡∏•‡∏≥‡πÅ‡∏™‡∏á‡∏ï‡∏≠‡∏ô Boost */
    #boostBeam {
      position: absolute;
      width: 140px;
      height: 35px;
      left: -9999px;
      bottom: 40px;
      background: linear-gradient(
        90deg,
        rgba(34,197,94,0),
        rgba(34,197,94,0.9),
        rgba(56,189,248,0.0)
      );
      filter: blur(8px);
      opacity: 0;
      transition: opacity 0.12s ease;
      pointer-events: none;
      z-index: 4;
      mix-blend-mode: screen;
    }

    .obstacle {
      position: absolute;
      bottom: 40px;
      border-radius: 6px;
      box-shadow: 0 0 12px rgba(15, 23, 42, 1);
      z-index: 3;
    }

    .obstacle.ground.tree { background: linear-gradient(to top, #14532d, #16a34a); border-radius: 4px 4px 0 0; }
    .obstacle.ground.bush { background: linear-gradient(to top, #166534, #22c55e); border-radius: 16px; }
    .obstacle.ground.rock { background: radial-gradient(circle at 30% 20%, #9ca3af, #4b5563); border-radius: 40% 60% 30% 70%; }
    .obstacle.ground.spike { background: repeating-linear-gradient(135deg, #fecaca 0, #fecaca 6px, #b91c1c 6px, #b91c1c 12px); }
    .obstacle.ground.crate { background: linear-gradient(135deg, #78350f, #fbbf24); box-shadow: 0 0 12px rgba(124,45,18,0.9); }
    .obstacle.ground.barrel { background: linear-gradient(180deg, #f97316, #c2410c); box-shadow: 0 0 14px rgba(249,115,22,0.95); border-radius: 6px; }
    .obstacle.ground.sign { background: linear-gradient(180deg, #facc15, #eab308); box-shadow: 0 0 14px rgba(234,179,8,0.95); position: relative; }
    .obstacle.ground.sign::before { content: "!"; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -60%); color: #1f2937; font-weight: 700; font-size: 18px; }
    .obstacle.ground.laser { background: linear-gradient(180deg, #ef4444, #f97316); box-shadow: 0 0 18px rgba(248,113,113,1); }

    .obstacle.air.bird { background: linear-gradient(135deg, #fee2e2, #ef4444, #7f1d1d); border: 2px solid #fecaca; box-shadow: 0 0 16px rgba(239,68,68,0.95); border-radius: 6px; }
    .obstacle.air.drone { background: radial-gradient(circle at 30% 30%, #e5e7eb, #64748b, #020617); border-radius: 40%; border: 2px solid #e5e7eb; box-shadow: 0 0 14px rgba(148,163,184,0.9); }
    .obstacle.air.fireball { background: radial-gradient(circle at 30% 30%, #fef9c3, #f97316, #7c2d12); border-radius: 50%; box-shadow: 0 0 16px rgba(249,115,22,0.95); }

    .platform {
      position: absolute;
      height: 10px;
      background: linear-gradient(to top, #020617, #111827);
      border-radius: 8px;
      box-shadow: 0 6px 14px rgba(15,23,42,0.95);
      border: 1px solid rgba(148,163,184,0.35);
      z-index: 2;
    }

    .hole {
      position: absolute;
      bottom: 0;
      height: 40px;
      background: linear-gradient(to top, #000000 0%, #020617 55%);
      border-radius: 6px 6px 0 0;
      box-shadow: inset 0 0 24px rgba(0,0,0,0.9), 0 -2px 0 rgba(148,163,184,0.6);
      z-index: 1;
      overflow: hidden;
    }
    .hole::before {
      content: "";
      position: absolute;
      left: 0; right: 0; bottom: 0;
      height: 14px;
      background: repeating-linear-gradient(-45deg, transparent 0 10px, #b91c1c 10px 20px);
      box-shadow: 0 -2px 8px rgba(248,113,113,0.8);
    }
    .hole::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: 2px;
      width: 60%;
      height: 10px;
      transform: translateX(-50%);
      background: radial-gradient(circle, rgba(248,113,113,0.7), transparent);
      opacity: 0.9;
    }

    .collectible {
      position: absolute;
      z-index: 4;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      line-height: 1;
      user-select: none;
      pointer-events: none;
      will-change: transform, opacity;
    }

    .collectible.coin {
      background: radial-gradient(circle at 30% 30%, #fef9c3, #facc15, #b45309);
      box-shadow: 0 0 12px rgba(250, 204, 21, 0.9);
    }

    .collectible.energy {
      background: radial-gradient(circle at 30% 20%, #fecaca, #ef4444, #b91c1c);
      box-shadow: 0 0 12px rgba(248, 113, 113, 0.95);
      font-size: 18px;
      transform: scale(1);
    }
    .collectible.energy.small  { transform: scale(0.85); }
    .collectible.energy.medium { transform: scale(1.0); }
    .collectible.energy.large  { transform: scale(1.25); }

    .collectible.magnet {
      background: radial-gradient(circle at 30% 20%, #e0f2fe, #38bdf8, #0369a1);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.95);
    }

    .collectible.boost {
      background: linear-gradient(90deg, #22c55e, #a3e635);
      box-shadow: 0 0 14px rgba(34, 197, 94, 0.95);
    }

    .collectible.giant {
      background: radial-gradient(circle at 30% 20%, #e0e7ff, #6366f1, #312e81);
      box-shadow: 0 0 14px rgba(129, 140, 248, 0.95);
    }

    #energyContainer {
      margin-top: 10px;
      width: 800px;
      max-width: 95vw;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }

    #energyLabel {
      font-size: 11px;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    #energyBarWrapper {
      flex: 1;
      height: 12px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #4b5563;
      overflow: hidden;
      box-shadow: 0 0 8px rgba(15,23,42,0.9);
    }

    #energyBar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #22c55e, #facc15, #fb923c);
      box-shadow: 0 0 12px rgba(250,204,21,0.8);
      transition: width 0.15s ease;
    }

    #energyText {
      width: 70px;
      text-align: right;
      font-size: 11px;
      color: #e5e7eb;
    }

    #scoreBoard {
      margin-top: 10px;
      font-size: 15px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    #coins { color: #facc15; }

    #cheatTimer {
      margin-top: 4px;
      font-size: 14px;
      min-height: 20px;
      color: #facc15;
      text-shadow: 0 0 8px rgba(250, 204, 21, 0.9);
    }

    #mission {
      margin-top: 6px;
      font-size: 12px;
      color: #9ca3af;
      max-width: 800px;
      text-align: center;
    }

    #message {
      margin-top: 6px;
      font-size: 13px;
      color: #9ca3af;
      text-align: center;
      max-width: 800px;
    }

    #itemGuide {
      margin-top: 8px;
      font-size: 12px;
      color: #e5e7eb;
      max-width: 800px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(148,163,184,0.45);
    }
    #itemGuide strong { color: #facc15; }
    #itemGuide ul { margin: 4px 0 0; padding-left: 18px; }
    #itemGuide li { margin-bottom: 2px; }

    #buttonsRow{
      margin-top: 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }

    #startBtn {
      padding: 8px 22px;
      border: none;
      border-radius: 999px;
      font-size: 14px;
      cursor: pointer;
      background: linear-gradient(to right, #22c55e, #2dd4bf);
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(34, 197, 94, 0.35);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s;
    }

    #fullscreenBtn{
      padding:8px 16px;
      border-radius:999px;
      border:1px solid #4b5563;
      background:radial-gradient(circle at 20% 0,#1f2937,#020617);
      color:#e5e7eb;
      font-size:13px;
      cursor:pointer;
      box-shadow:0 8px 18px rgba(15,23,42,0.9);
    }

    #touchControls {
      margin-top: 14px;
      width: 800px;
      max-width: 95vw;
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .ctrl-btn {
      flex: 1;
      padding: 12px 10px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: radial-gradient(circle at 20% 0, #1f2937, #020617);
      color: #e5e7eb;
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.04em;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(15,23,42,0.9);
      text-transform: uppercase;
    }

    .ctrl-btn span {
      font-size: 11px;
      display: block;
      opacity: 0.7;
      margin-top: 2px;
    }

    /* === ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏™‡∏±‡πà‡∏ô‡∏à‡∏≠ / ‡πÅ‡∏ü‡∏•‡∏ä‡∏ï‡∏≠‡∏ô‡πÇ‡∏î‡∏ô‡∏ä‡∏ô === */
    @keyframes hitShake {
      0%   { transform: translate(0, 0); }
      20%  { transform: translate(-4px, 2px); }
      40%  { transform: translate(4px, -2px); }
      60%  { transform: translate(-3px, 1px); }
      80%  { transform: translate(3px, -1px); }
      100% { transform: translate(0, 0); }
    }
    #gameContainer.shake { animation: hitShake 0.25s ease; }

    #hitFlash {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, rgba(248,250,252,0.35), transparent 60%);
      mix-blend-mode: screen;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease;
      z-index: 999;
    }
    body.hit-blink #hitFlash { opacity: 1; }

    /* === GAME OVER POPUP === */
    #gameOverModal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 18px;
      background: rgba(2,6,23,0.75);
      backdrop-filter: blur(6px);
    }
    #gameOverModal.show { display: flex; }

    .modal-card {
      width: min(520px, 92vw);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.92);
      box-shadow: 0 24px 70px rgba(0,0,0,0.55);
      padding: 16px;
      text-align: center;
      animation: modalPop 0.18s ease;
    }
    @keyframes modalPop {
      from { transform: translateY(8px) scale(0.98); opacity: 0.6; }
      to   { transform: translateY(0) scale(1); opacity: 1; }
    }

    .modal-title{
      font-size: 18px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 8px;
      color: #facc15;
      text-shadow: 0 0 14px rgba(250,204,21,0.25);
    }
    .modal-stats{
      font-size: 14px;
      color: #e5e7eb;
      margin-bottom: 14px;
      line-height: 1.6;
    }
    .modal-actions{
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }
    .modal-btn{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: #e5e7eb;
      background: radial-gradient(circle at 20% 0, #1f2937, #020617);
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
    }
    .modal-btn.primary{
      border: none;
      background: linear-gradient(to right, #22c55e, #2dd4bf);
      color: #022c22;
      box-shadow: 0 14px 32px rgba(34, 197, 94, 0.35);
    }
    .modal-btn.revive{
      border: 1px solid rgba(250,204,21,0.55);
      background: radial-gradient(circle at 30% 20%, rgba(250,204,21,0.18), rgba(15,23,42,0.92));
      color: #facc15;
    }
    .modal-btn:active{ transform: translateY(1px); }

    @media (max-width: 600px) {
      #gameContainer { height: 230px; }
      #player { left: 40px; }
      #touchControls { margin-top: 12px; gap: 8px; }
      .ctrl-btn { padding: 10px 8px; font-size: 13px; }
      #energyContainer { font-size: 12px; }
      #energyText { width: 54px; font-size: 10px; }
    }
  </style>
</head>
<body>
  <h1>PHANToM Runner</h1>
  <div id="hint">
    Space / ‚Üë = ‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î (2 ‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞) ‚Ä¢ ‚Üì = ‡∏´‡∏°‡∏≠‡∏ö ‚Ä¢ ‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏•‡∏≠‡∏¢/‡∏ö‡∏±‡∏ô‡πÑ‡∏î ‚Ä¢ ‡∏´‡∏•‡∏∏‡∏°‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å (‡∏ï‡∏Å‡πÑ‡∏î‡πâ ‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ) ‚Ä¢ ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç / ‡∏´‡∏±‡∏ß‡πÉ‡∏à / Magnet / Boost(‡∏≠‡∏°‡∏ï‡∏∞) / Giant
  </div>

  <div id="gameContainer">
    <div id="ground"></div>
    <div id="boostBeam"></div>

    <div id="player">
      <img src="phantom-runner.png" alt="PHANToM" />
    </div>
  </div>

  <div id="touchControls">
    <button id="btnJump" class="ctrl-btn">
      ‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î
      <span>JUMP / SPACE</span>
    </button>
    <button id="btnDuck" class="ctrl-btn">
      ‡∏´‡∏°‡∏≠‡∏ö
      <span>DUCK / ‚Üì</span>
    </button>
  </div>

  <div id="energyContainer">
    <div id="energyLabel">Energy</div>
    <div id="energyBarWrapper">
      <div id="energyBar"></div>
    </div>
    <div id="energyText">100 / 100</div>
  </div>

  <div id="scoreBoard">
    <div id="score">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: 0</div>
    <div id="coins">‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: 0</div>
    <div id="bestScore">‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: 0</div>
  </div>
  <div id="cheatTimer"></div>
  <div id="mission"></div>
  <div id="message">‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà" ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î Space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°</div>

  <div id="itemGuide">
    <strong>‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°:</strong>
    <ul>
      <li>ü§ë <b>‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (Coin)</b> : +2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡πà‡∏≠‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏Å‡∏≠‡∏£‡πå‡∏£‡∏ß‡∏°</li>
      <li>‚ù§Ô∏è <b>‡∏´‡∏±‡∏ß‡πÉ‡∏à (Energy)</b> : ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Energy ‡∏ï‡∏≤‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏±‡∏ß‡πÉ‡∏à (‡πÄ‡∏•‡πá‡∏Å/‡∏Å‡∏•‡∏≤‡∏á/‡πÉ‡∏´‡∏ç‡πà)</li>
      <li>üß≤ <b>Magnet</b> : ‡∏î‡∏π‡∏î‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏£‡∏≠‡∏ö ‡πÜ ‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å ‡πÄ‡∏Å‡∏∑‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏à‡∏≠ ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß</li>
      <li>‚ö° <b>Boost</b> : ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß (‡∏ä‡∏ô‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÇ‡∏î‡∏ô‡∏î‡∏≤‡πÄ‡∏°‡∏à)</li>
      <li>üåÄ <b>Giant</b> : ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏£‡πà‡∏≤‡∏á ‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô ‡∏ä‡∏ô‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡∏ö‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏û‡∏±‡∏á‡πÑ‡∏î‡πâ</li>
    </ul>
  </div>

  <div id="buttonsRow">
    <button id="startBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
    <button id="fullscreenBtn">‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</button>
  </div>

  <div id="hitFlash"></div>

  <div id="gameOverModal">
    <div class="modal-card">
      <div class="modal-title">GAME OVER</div>
      <div class="modal-stats" id="gameOverStats">...</div>

      <div class="modal-actions">
        <button class="modal-btn revive" id="reviveBtn">‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û (‡πÉ‡∏ä‡πâ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç 20)</button>
        <button class="modal-btn primary" id="restartFromModalBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
      </div>

      <div style="margin-top:10px; font-size:12px; color:#9ca3af;">
        * ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏û‡∏≠ (>= 20)
      </div>
    </div>
  </div>

  <script>
    (function () {
      // =========================
      // üîß CONFIG ‡∏õ‡∏£‡∏±‡∏ö‡∏à‡∏π‡∏ô‡πÄ‡∏Å‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
      // =========================

      const CFG_GRAVITY = 0.9;
      const CFG_JUMP_STRENGTH = 13.5;
      const CFG_MAX_JUMPS = 2;

      // ‡∏î‡∏≤‡πÄ‡∏°‡∏à‡∏•‡∏î‡∏•‡∏á 40%
      const CFG_MAX_ENERGY = 100;
      const CFG_ENERGY_DECAY_PER_SEC = 4;
      const CFG_DAMAGE_GROUND = 15; // 25 -> 15
      const CFG_DAMAGE_AIR = 21;    // 35 -> 21

      const CFG_START_SPEED = 6;
      const CFG_SPEED_UP_EVERY_SCORE = 5;
      const CFG_SPEED_UP_AMOUNT = 0.5;
      const CFG_BOOST_MULTIPLIER = 1.6;

      // ‡∏ä‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏ä‡∏∞‡∏•‡∏≠ 20% 0.5 ‡∏ß‡∏¥
      const CFG_HIT_SLOW_FACTOR = 0.8;
      const CFG_HIT_SLOW_DURATION = 500;

      const CFG_HOLE_CHANCE = 0.18;
      const CFG_TRAP_Y = -60;

      const CFG_CHEAT_INVINCIBLE_DURATION = 10000;
      const CFG_MAGNET_DURATION = 10000;
      const CFG_BOOST_DURATION = 5000;
      const CFG_GIANT_DURATION = 6000;

      // ‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏®‡∏°‡∏µ magnet ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
      const CFG_MAGNET_RADIUS = 400;

      const CFG_HEART_SMALL_GAIN = 15;
      const CFG_HEART_MEDIUM_GAIN = 25;
      const CFG_HEART_LARGE_GAIN = 40;

      // ‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏∏‡∏Å 40 ‡∏ß‡∏¥
      const CFG_BIG_HEART_EVERY_MS = 40000;

      const CFG_MISSION_COIN_TARGET = 20;
      const CFG_MISSION_DJ_TARGET = 10;
      const CFG_MISSION_OBS_TARGET = 30;

      // ‡∏Ç‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏ñ‡∏µ‡πà‡∏Ç‡∏∂‡πâ‡∏ô (‡∏•‡∏î‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ)
      const CFG_COLLECTIBLE_BASE_INTERVAL = 1200;
      const CFG_COLLECTIBLE_MIN_INTERVAL = 450;

      const CFG_PLATFORM_MIN_INTERVAL = 2000;
      const CFG_PLATFORM_MAX_INTERVAL = 4500;

      const CFG_CHEAT_WINDOW = 1000;

      // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏∏‡πà‡∏° (‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏¢‡∏≠‡∏∞)
      const CFG_CHANCE_COIN = 0.72;
      const CFG_CHANCE_ENERGY = 0.14; // ‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏Ñ‡πà small/medium
      const CFG_CHANCE_MAGNET = 0.08;
      const CFG_CHANCE_BOOST = 0.04;
      // ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ = giant

      // ‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û
      const CFG_REVIVE_COST = 20;
      const CFG_REVIVE_ENERGY = 60;
      const CFG_REVIVE_INVINCIBLE_MS = 1500;

      // ==========
      // Logic ‡πÄ‡∏Å‡∏°
      // ==========

      const gameContainer = document.getElementById("gameContainer");
      const player = document.getElementById("player");
      const scoreEl = document.getElementById("score");
      const bestScoreEl = document.getElementById("bestScore");
      const messageEl = document.getElementById("message");
      const startBtn = document.getElementById("startBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const cheatTimerEl = document.getElementById("cheatTimer");
      const btnJump = document.getElementById("btnJump");
      const btnDuck = document.getElementById("btnDuck");
      const energyBar = document.getElementById("energyBar");
      const energyText = document.getElementById("energyText");
      const coinsEl = document.getElementById("coins");
      const missionEl = document.getElementById("mission");
      const boostBeam = document.getElementById("boostBeam");

      const gameOverModal = document.getElementById("gameOverModal");
      const gameOverStats = document.getElementById("gameOverStats");
      const reviveBtn = document.getElementById("reviveBtn");
      const restartFromModalBtn = document.getElementById("restartFromModalBtn");

      const groundY = 40;
      const playerBaseLeft = parseFloat(getComputedStyle(player).left) || 80;

      const gravity = CFG_GRAVITY;
      const maxJumps = CFG_MAX_JUMPS;
      let playerY = groundY;
      let prevPlayerY = groundY;
      let isJumping = false;
      let jumpVelocity = 0;
      let jumpsLeft = maxJumps;

      let isDucking = false;

      const maxEnergy = CFG_MAX_ENERGY;
      let energy = maxEnergy;
      const damageGround = CFG_DAMAGE_GROUND;
      const damageAir = CFG_DAMAGE_AIR;

      let score = 0;
      let bestScore = Number(localStorage.getItem("phantom_runner_best") || 0);
      let coins = 0;
      let coinsCollected = 0;
      let totalDoubleJumps = 0;
      let obstaclesPassed = 0;

      const MISSION_COIN_TARGET = CFG_MISSION_COIN_TARGET;
      const MISSION_DJ_TARGET = CFG_MISSION_DJ_TARGET;
      const MISSION_OBS_TARGET = CFG_MISSION_OBS_TARGET;

      bestScoreEl.textContent = "‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: " + bestScore;

      let obstacles = [];
      let collectibles = [];
      let platforms = [];
      let holes = [];
      let speed = CFG_START_SPEED;

      const BOOST_MULTIPLIER = CFG_BOOST_MULTIPLIER;
      const HOLE_CHANCE = CFG_HOLE_CHANCE;

      // ‚úÖ ‡πÅ‡∏Å‡πâ‡∏à‡∏∏‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤ "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°"
      let gameOver = true;

      let frameId = null;
      let lastTime = null;

      let timeSinceLastObstacle = 0;
      let nextSpawnIn = 1000;

      let timeSinceLastCollectible = 0;

      let timeSinceLastPlatform = 0;
      let nextPlatformIn = CFG_PLATFORM_MIN_INTERVAL + Math.random() * (CFG_PLATFORM_MAX_INTERVAL - CFG_PLATFORM_MIN_INTERVAL);

      let invincible = false;
      let invincibleTimer = 0;

      let magnetActive = false;
      let magnetTimer = 0;

      let boostActive = false;
      let boostTimer = 0;

      let giantActive = false;
      let giantTimer = 0;

      let hitSlowTimer = 0;

      let bigHeartTimer = 0;

      let cheatEvents = [];

      const TRAP_Y = CFG_TRAP_Y;

      function randomBetween(min, max) {
        return Math.random() * (max - min) + min;
      }

      function updateEnergyUI() {
        const ratio = Math.max(0, Math.min(1, energy / maxEnergy));
        energyBar.style.width = (ratio * 100) + "%";
        energyText.textContent = Math.round(energy) + " / " + maxEnergy;
      }

      function updateMissionUI() {
        if (!missionEl) return;
        missionEl.textContent =
          "Mission: ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç " + coinsCollected + "/" + MISSION_COIN_TARGET +
          " ‚Ä¢ Double Jump " + totalDoubleJumps + "/" + MISSION_DJ_TARGET +
          " ‚Ä¢ ‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ " + obstaclesPassed + "/" + MISSION_OBS_TARGET;
      }

      function clearArrays() {
        obstacles.forEach(o => o.remove());
        obstacles = [];
        collectibles.forEach(c => c.remove());
        collectibles = [];
        platforms.forEach(p => p.remove());
        platforms = [];
        holes.forEach(h => h.remove());
        holes = [];
      }

      function hideGameOverModal(){
        gameOverModal.classList.remove("show");
      }

      function showGameOverModal(){
        gameOverStats.innerHTML =
          "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <b>" + score + "</b><br/>" +
          "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: <b style='color:#facc15'>" + coins + "</b><br/>" +
          "‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: <b>" + bestScore + "</b>";

        if (coins >= CFG_REVIVE_COST) {
          reviveBtn.style.display = "block";
          reviveBtn.textContent = "‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û (‡πÉ‡∏ä‡πâ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç " + CFG_REVIVE_COST + ")";
        } else {
          reviveBtn.style.display = "none";
        }

        gameOverModal.classList.add("show");
      }

      function resetGame() {
        hideGameOverModal();
        clearArrays();

        score = 0;
        coins = 0;
        coinsCollected = 0;
        totalDoubleJumps = 0;
        obstaclesPassed = 0;
        speed = CFG_START_SPEED;

        scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
        coinsEl.textContent = "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: " + coins;

        gameOver = false;

        isJumping = false;
        isDucking = false;
        playerY = groundY;
        prevPlayerY = groundY;
        jumpVelocity = 0;
        jumpsLeft = maxJumps;
        player.style.bottom = playerY + "px";
        player.classList.remove("duck", "invincible", "giant", "double-jump");

        invincible = false;
        invincibleTimer = 0;
        cheatEvents = [];
        cheatTimerEl.textContent = "";

        magnetActive = false;
        magnetTimer = 0;
        boostActive = false;
        boostTimer = 0;
        giantActive = false;
        giantTimer = 0;

        hitSlowTimer = 0;

        bigHeartTimer = 0;

        energy = maxEnergy;
        updateEnergyUI();

        timeSinceLastObstacle = 0;
        nextSpawnIn = 800 + Math.random() * 600;

        timeSinceLastCollectible = 0;

        timeSinceLastPlatform = 0;
        nextPlatformIn = CFG_PLATFORM_MIN_INTERVAL + Math.random() * (CFG_PLATFORM_MAX_INTERVAL - CFG_PLATFORM_MIN_INTERVAL);

        updateMissionUI();
        messageEl.textContent = "‡∏´‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏∏‡∏°‡∏Å‡∏±‡∏ö‡∏î‡∏±‡∏Å‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î!";

        if (boostBeam) {
          boostBeam.style.opacity = 0;
          boostBeam.style.left = "-9999px";
        }

        if (frameId) cancelAnimationFrame(frameId);
        lastTime = null;
        frameId = requestAnimationFrame(gameLoop);

        spawnObstacle();
      }

      function reviveGame(){
        if (coins < CFG_REVIVE_COST) return;

        hideGameOverModal();

        coins -= CFG_REVIVE_COST;
        coinsEl.textContent = "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: " + coins;

        clearArrays();

        energy = Math.min(maxEnergy, CFG_REVIVE_ENERGY);
        updateEnergyUI();

        isJumping = false;
        isDucking = false;
        playerY = groundY;
        prevPlayerY = groundY;
        jumpVelocity = 0;
        jumpsLeft = maxJumps;
        player.style.bottom = playerY + "px";
        player.classList.remove("duck", "giant", "double-jump");

        magnetActive = false; magnetTimer = 0;
        boostActive = false; boostTimer = 0;
        giantActive = false; giantTimer = 0;

        invincible = true;
        invincibleTimer = Math.max(invincibleTimer, CFG_REVIVE_INVINCIBLE_MS);
        player.classList.add("invincible");
        cheatTimerEl.textContent = "‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏¢ " + Math.ceil(CFG_REVIVE_INVINCIBLE_MS/1000) + " ‡∏ß‡∏¥ ‚ú®";

        hitSlowTimer = 0;

        // ‚úÖ ‡πÅ‡∏Å‡πâ spawn ‡∏ï‡∏¥‡∏î ‡πÜ ‡∏ï‡∏≠‡∏ô‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û
        timeSinceLastObstacle = 0;
        nextSpawnIn = 900 + Math.random() * 600;
        timeSinceLastCollectible = 0;
        timeSinceLastPlatform = 0;
        nextPlatformIn = CFG_PLATFORM_MIN_INTERVAL + Math.random() * (CFG_PLATFORM_MAX_INTERVAL - CFG_PLATFORM_MIN_INTERVAL);

        messageEl.textContent = "‡∏Ñ‡∏∑‡∏ô‡∏ä‡∏µ‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏•‡∏∏‡∏¢‡∏ï‡πà‡∏≠ üî•";

        gameOver = false;
        if (frameId) cancelAnimationFrame(frameId);
        lastTime = null;
        frameId = requestAnimationFrame(gameLoop);

        spawnObstacle();
      }

      function spawnHole() {
        const h = document.createElement("div");
        h.classList.add("hole");
        const width = randomBetween(80, 160);
        h.style.width = width + "px";
        h.style.left = gameContainer.offsetWidth + "px";
        h.style.bottom = "0px";
        gameContainer.appendChild(h);
        holes.push(h);
      }

      function spawnObstacle() {
        const isAir = Math.random() < 0.35;

        if (!isAir && Math.random() < HOLE_CHANCE) {
          spawnHole();
          return;
        }

        const obs = document.createElement("div");
        obs.classList.add("obstacle");

        if (isAir) {
          const airTypes = ["bird", "drone", "fireball"];
          const kind = airTypes[Math.floor(Math.random() * airTypes.length)];
          obs.classList.add("air", kind);

          const height = randomBetween(24, 32);
          const width = randomBetween(34, 40);
          obs.style.width = width + "px";
          obs.style.height = height + "px";
          const bottom = randomBetween(95, 125);
          obs.style.bottom = bottom + "px";
        } else {
          obs.classList.add("ground");
          const groundTypes = ["tree", "bush", "rock", "spike", "crate", "barrel", "sign", "laser"];
          const kind = groundTypes[Math.floor(Math.random() * groundTypes.length)];
          obs.classList.add(kind);

          const height = randomBetween(45, 80);
          const width = randomBetween(22, 40);
          obs.style.width = width + "px";
          obs.style.height = height + "px";
          obs.style.bottom = groundY + "px";
        }

        obs.style.left = gameContainer.offsetWidth + "px";
        gameContainer.appendChild(obs);
        obstacles.push(obs);
      }

      function spawnCollectibleGeneric(type, opts = {}) {
        const c = document.createElement("div");
        c.classList.add("collectible");

        if (type === "coin") {
          c.classList.add("coin");
          c.textContent = "ü§ë";
        } else if (type === "energy") {
          c.classList.add("energy");
          const size = opts.size || "medium";
          c.classList.add(size);
          c.textContent = "‚ù§Ô∏è";
          c.dataset.energy = String(opts.energyGain || CFG_HEART_MEDIUM_GAIN);
        } else if (type === "magnet") {
          c.classList.add("magnet");
          c.textContent = "üß≤";
        } else if (type === "boost") {
          c.classList.add("boost");
          c.textContent = "‚ö°";
        } else if (type === "giant") {
          c.classList.add("giant");
          c.textContent = "üåÄ";
        }

        const lane = Math.floor(Math.random() * 3);
        let bottom;
        if (lane === 0) bottom = groundY + 60;
        else if (lane === 1) bottom = groundY + 110;
        else bottom = groundY + 150;

        if (typeof opts.bottom === "number") bottom = opts.bottom;

        c.style.bottom = bottom + "px";
        c.style.left = gameContainer.offsetWidth + "px";

        gameContainer.appendChild(c);
        collectibles.push(c);
      }

      function spawnBigHeart() {
        spawnCollectibleGeneric("energy", {
          size: "large",
          energyGain: CFG_HEART_LARGE_GAIN
        });
        messageEl.textContent = "‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÉ‡∏´‡∏ç‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è! ‚ù§Ô∏è (+Energy ‡πÄ‡∏¢‡∏≠‡∏∞)";
      }

      function spawnCollectibleRandom() {
        const r = Math.random();
        const a = CFG_CHANCE_COIN;
        const b = a + CFG_CHANCE_ENERGY;
        const c = b + CFG_CHANCE_MAGNET;
        const d = c + CFG_CHANCE_BOOST;

        if (r < a) {
          spawnCollectibleGeneric("coin");
        } else if (r < b) {
          const pick = Math.random() < 0.55 ? "small" : "medium";
          const gain = pick === "small" ? CFG_HEART_SMALL_GAIN : CFG_HEART_MEDIUM_GAIN;
          spawnCollectibleGeneric("energy", { size: pick, energyGain: gain });
        } else if (r < c) {
          spawnCollectibleGeneric("magnet");
        } else if (r < d) {
          spawnCollectibleGeneric("boost");
        } else {
          spawnCollectibleGeneric("giant");
        }
      }

      function spawnPlatformGroup() {
        const num = Math.random() < 0.5 ? 2 : 3;
        const baseBottom = groundY + randomBetween(45, 130);
        const step = 24;
        const goingUp = Math.random() < 0.5;
        const baseLeft = gameContainer.offsetWidth + 80;

        for (let i = 0; i < num; i++) {
          const p = document.createElement("div");
          p.classList.add("platform");
          const width = randomBetween(80, 150);
          const spacing = 20;
          const left = baseLeft + i * (width + spacing);
          const bottom = baseBottom + (goingUp ? i : -i) * step;

          p.style.width = width + "px";
          p.style.left = left + "px";
          p.style.bottom = bottom + "px";

          gameContainer.appendChild(p);
          platforms.push(p);
        }
      }

      function getEffectiveSpeed() {
        let s = speed;
        if (boostActive) s *= BOOST_MULTIPLIER;
        if (hitSlowTimer > 0) s *= CFG_HIT_SLOW_FACTOR;
        return s;
      }

      function triggerHitVFX() {
        gameContainer.classList.remove("shake");
        void gameContainer.offsetWidth;
        gameContainer.classList.add("shake");

        document.body.classList.add("hit-blink");
        setTimeout(() => {
          document.body.classList.remove("hit-blink");
        }, 120);
      }

      function pullCollectibleToPlayer(c) {
        if (c.dataset.pulled === "1") return;
        c.dataset.pulled = "1";

        const pr = player.getBoundingClientRect();
        const cr = c.getBoundingClientRect();

        const targetX = pr.left + pr.width / 2;
        const targetY = pr.top + pr.height / 2;
        const cx = cr.left + cr.width / 2;
        const cy = cr.top + cr.height / 2;

        const dx = targetX - cx;
        const dy = targetY - cy;

        c.style.transition = "transform 0.2s linear, opacity 0.2s linear";
        c.style.transform = "translate(" + dx + "px," + dy + "px) scale(0.8)";
        c.style.opacity = "0.15";

        setTimeout(() => {
          if (!c.parentNode) return;
          applyCollectibleEffect(c);
          c.remove();
          collectibles = collectibles.filter(item => item !== c);
        }, 190);
      }

      function applyCollectibleEffect(c) {
        if (c.classList.contains("coin")) {
          coins += 1;
          coinsCollected += 1;
          score += 2;
          coinsEl.textContent = "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç: " + coins;
          scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
        } else if (c.classList.contains("energy")) {
          const gain = parseInt(c.dataset.energy || "20", 10);
          energy = Math.min(maxEnergy, energy + gain);
          updateEnergyUI();
        } else if (c.classList.contains("magnet")) {
          magnetActive = true;
          magnetTimer = CFG_MAGNET_DURATION;
          messageEl.textContent = "Magnet: ‡∏î‡∏π‡∏î‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÅ‡∏ó‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏à‡∏≠ ‚ú®";
        } else if (c.classList.contains("boost")) {
          boostActive = true;
          boostTimer = CFG_BOOST_DURATION;
          invincible = true;
          invincibleTimer = Math.max(invincibleTimer, CFG_BOOST_DURATION);
          player.classList.add("invincible");
          cheatTimerEl.textContent = "Boost: ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‚ö°";
          messageEl.textContent = "Boost: ‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô + ‡∏≠‡∏°‡∏ï‡∏∞‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß ‚ö°";
        } else if (c.classList.contains("giant")) {
          giantActive = true;
          giantTimer = CFG_GIANT_DURATION;
          player.classList.add("giant");
          messageEl.textContent = "Giant: PHANToM ‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏ç‡πà ‡∏ä‡∏ô‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡πÅ‡∏ï‡∏Å‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢ üí•";
        }

        updateMissionUI();
      }

      function updateObstacles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        const toRemove = [];

        obstacles.forEach((obs, index) => {
          if (gameOver) return;

          const left = parseFloat(obs.style.left);
          const newLeft = left - moveX;
          obs.style.left = newLeft + "px";

          if (newLeft + obs.offsetWidth < 0) {
            toRemove.push(index);
            score += 1;
            obstaclesPassed += 1;
            scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
            updateMissionUI();

            if (CFG_SPEED_UP_EVERY_SCORE > 0 && score % CFG_SPEED_UP_EVERY_SCORE === 0) {
              speed += CFG_SPEED_UP_AMOUNT;
            }
          }

          if (!gameOver && isColliding(player, obs)) {
            if (invincible || giantActive) {
              score += 2;
              obstaclesPassed += 1;
              scoreEl.textContent = "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: " + score;
              updateMissionUI();
              toRemove.push(index);
            } else {
              const isAir = obs.classList.contains("air");
              const dmg = isAir ? damageAir : damageGround;
              energy -= dmg;

              if (energy <= 0) {
                energy = 0;
                updateEnergyUI();
                endGame();
                return;
              } else {
                updateEnergyUI();
                obs.style.opacity = "0.4";
                setTimeout(() => { if (obs && obs.style) obs.style.opacity = "1"; }, 100);

                triggerHitVFX();
                hitSlowTimer = CFG_HIT_SLOW_DURATION;
              }
            }
          }
        });

        toRemove.reverse().forEach(i => {
          if (obstacles[i]) obstacles[i].remove();
          obstacles.splice(i, 1);
        });

        timeSinceLastObstacle += delta;

        const minInterval = Math.max(550, 1000 - score * 5);
        const maxInterval = Math.max(minInterval + 300, 1600 - score * 8);

        if (timeSinceLastObstacle >= nextSpawnIn) {
          let canSpawn = true;
          if (obstacles.length > 0) {
            const lastObs = obstacles[obstacles.length - 1];
            const lastRect = lastObs.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            const distance = containerRect.right - lastRect.right;
            if (distance < 180) canSpawn = false;
          }

          if (canSpawn) {
            spawnObstacle();
            timeSinceLastObstacle = 0;
            nextSpawnIn = randomBetween(minInterval, maxInterval);
          } else {
            timeSinceLastObstacle = minInterval - 50;
          }
        }
      }

      function updatePlatforms(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        const toRemove = [];

        platforms.forEach((p, index) => {
          const left = parseFloat(p.style.left);
          const newLeft = left - moveX;
          p.style.left = newLeft + "px";

          if (newLeft + p.offsetWidth < 0) toRemove.push(index);
        });

        toRemove.reverse().forEach(i => {
          if (platforms[i]) platforms[i].remove();
          platforms.splice(i, 1);
        });

        timeSinceLastPlatform += delta;
        if (timeSinceLastPlatform >= nextPlatformIn) {
          if (platforms.length < 10) spawnPlatformGroup();
          timeSinceLastPlatform = 0;
          nextPlatformIn = CFG_PLATFORM_MIN_INTERVAL + Math.random() * (CFG_PLATFORM_MAX_INTERVAL - CFG_PLATFORM_MIN_INTERVAL);
        }
      }

      function updateHoles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        const toRemove = [];
        holes.forEach((h, index) => {
          const left = parseFloat(h.style.left);
          const newLeft = left - moveX;
          h.style.left = newLeft + "px";
          if (newLeft + h.offsetWidth < 0) toRemove.push(index);
        });
        toRemove.reverse().forEach(i => {
          if (holes[i]) holes[i].remove();
          holes.splice(i, 1);
        });
      }

      function updateCollectibles(delta) {
        const moveX = getEffectiveSpeed() * (delta / 16.67);
        const toRemove = [];

        let playerCenterX = 0;
        let playerCenterY = 0;
        if (magnetActive) {
          const pr = player.getBoundingClientRect();
          playerCenterX = pr.left + pr.width / 2;
          playerCenterY = pr.top + pr.height / 2;
        }

        collectibles.forEach((c, index) => {
          if (c.dataset.pulled === "1") return;

          const left = parseFloat(c.style.left);
          const newLeft = left - moveX;
          c.style.left = newLeft + "px";

          if (newLeft + c.offsetWidth < 0) {
            toRemove.push(index);
            return;
          }

          if (magnetActive && (c.classList.contains("coin") || c.classList.contains("energy"))) {
            const cr = c.getBoundingClientRect();
            const cx = cr.left + cr.width / 2;
            const cy = cr.top + cr.height / 2;
            const dx = playerCenterX - cx;
            const dy = playerCenterY - cy;
            const dist = Math.hypot(dx, dy);
            if (dist < CFG_MAGNET_RADIUS) {
              pullCollectibleToPlayer(c);
              return;
            }
          }

          if (!gameOver && isColliding(player, c)) {
            applyCollectibleEffect(c);
            toRemove.push(index);
          }
        });

        toRemove.reverse().forEach(i => {
          if (collectibles[i]) collectibles[i].remove();
          collectibles.splice(i, 1);
        });

        timeSinceLastCollectible += delta;
        const interval = Math.max(CFG_COLLECTIBLE_MIN_INTERVAL, CFG_COLLECTIBLE_BASE_INTERVAL - score * 4);
        if (timeSinceLastCollectible >= interval) {
          spawnCollectibleRandom();
          timeSinceLastCollectible = 0;
        }

        bigHeartTimer += delta;
        while (bigHeartTimer >= CFG_BIG_HEART_EVERY_MS) {
          if (collectibles.length < 24 && !gameOver) {
            spawnBigHeart();
          }
          bigHeartTimer -= CFG_BIG_HEART_EVERY_MS;
        }
      }

      function isColliding(a, b) {
        const r1 = a.getBoundingClientRect();
        const r2 = b.getBoundingClientRect();
        return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
      }

      function updatePlayer(delta) {
        const factor = delta / 16.67;
        prevPlayerY = playerY;

        jumpVelocity -= gravity * factor;
        playerY += jumpVelocity * factor;

        let supportY = groundY;
        const isFalling = jumpVelocity <= 0;

        const playerRect = player.getBoundingClientRect();
        const playerLeftScreen = playerRect.left;
        const playerRightScreen = playerRect.right;

        const playerStyleLeft = parseFloat(getComputedStyle(player).left);
        const playerStyleRight = playerStyleLeft + player.offsetWidth;

        platforms.forEach(p => {
          const pRect = p.getBoundingClientRect();
          const pLeft = pRect.left;
          const pRight = pRect.right;

          const platformBottom = parseFloat(p.style.bottom);
          const platformTop = platformBottom + p.offsetHeight;

          const horizontallyOver = (playerRightScreen > pLeft + 5) && (playerLeftScreen < pRight - 5);

          if (horizontallyOver && isFalling && prevPlayerY >= platformTop && playerY <= platformTop) {
            if (platformTop > supportY) supportY = platformTop;
          }
        });

        let holeUnder = false;
        holes.forEach(h => {
          const hLeft = parseFloat(h.style.left);
          const hRight = hLeft + h.offsetWidth;
          if (hRight > playerStyleLeft + 5 && hLeft < playerStyleRight - 5) holeUnder = true;
        });

        if (playerY <= supportY) {
          if (!(supportY === groundY && holeUnder)) {
            playerY = supportY;
            jumpVelocity = 0;
            isJumping = false;
            jumpsLeft = maxJumps;
          }
        }

        player.style.bottom = playerY + "px";

        if (boostBeam) {
          if (boostActive) {
            boostBeam.style.opacity = 1;
            boostBeam.style.left = (playerBaseLeft - 90) + "px";
            boostBeam.style.bottom = (playerY + 8) + "px";
          } else if (!boostActive && boostBeam.style.opacity !== "0") {
            boostBeam.style.opacity = 0;
          }
        }
      }

      function checkHoleTrap() {
        if (playerY < TRAP_Y) endGame();
      }

      function gameLoop(timestamp) {
        if (gameOver) return;
        if (!lastTime) lastTime = timestamp;
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        if (!invincible) {
          energy -= CFG_ENERGY_DECAY_PER_SEC * (delta / 1000);
          if (energy <= 0) {
            energy = 0;
            updateEnergyUI();
            endGame();
            return;
          }
        }
        updateEnergyUI();

        updatePlayer(delta);
        updatePlatforms(delta);
        updateHoles(delta);
        checkHoleTrap();
        if (gameOver) return;

        updateObstacles(delta);
        updateCollectibles(delta);

        if (invincible) {
          invincibleTimer -= delta;
          if (invincibleTimer <= 0) {
            invincible = false;
            player.classList.remove("invincible");
            cheatTimerEl.textContent = "";
            if (!boostActive) messageEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß! ‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÉ‡∏´‡πâ‡∏î‡∏µ üòà";
          } else if (invincibleTimer <= 3000) {
            cheatTimerEl.textContent = "‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞: " + Math.ceil(invincibleTimer / 1000) + " ‡∏ß‡∏¥";
          }
        }

        if (magnetActive) {
          magnetTimer -= delta;
          if (magnetTimer <= 0) magnetActive = false;
        }

        if (boostActive) {
          boostTimer -= delta;
          if (boostTimer <= 0) boostActive = false;
        }

        if (giantActive) {
          giantTimer -= delta;
          if (giantTimer <= 0) {
            giantActive = false;
            player.classList.remove("giant");
          }
        }

        if (hitSlowTimer > 0) {
          hitSlowTimer -= delta;
          if (hitSlowTimer < 0) hitSlowTimer = 0;
        }

        frameId = requestAnimationFrame(gameLoop);
      }

      function endGame() {
        if (gameOver) return;
        gameOver = true;
        if (frameId) cancelAnimationFrame(frameId);

        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem("phantom_runner_best", bestScore);
        }
        bestScoreEl.textContent = "‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: " + bestScore;

        cheatTimerEl.textContent = "";
        messageEl.textContent = "Game Over!";

        if (boostBeam) boostBeam.style.opacity = 0;

        showGameOverModal();
      }

      function handleJump() {
        if (gameOver) return;

        if (jumpsLeft > 0) {
          if (isDucking) setDuck(false);

          if (jumpsLeft === 1) {
            totalDoubleJumps += 1;
            updateMissionUI();
            player.classList.remove("double-jump");
            void player.offsetWidth;
            player.classList.add("double-jump");
          }

          isJumping = true;
          jumpVelocity = CFG_JUMP_STRENGTH;
          jumpsLeft -= 1;
        }
      }

      function setDuck(state) {
        if (gameOver) return;
        if (state && !isDucking) {
          isDucking = true;
          player.classList.add("duck");
        } else if (!state && isDucking) {
          isDucking = false;
          player.classList.remove("duck");
        }
      }

      function registerCheat(code) {
        const now = performance.now();
        if (code !== "ArrowDown" && code !== "ArrowUp" && code !== "Space") return;

        const symbol = (code === "ArrowDown") ? "D" : "U";
        cheatEvents.push({ symbol, time: now });

        const cutoff = now - CFG_CHEAT_WINDOW;
        cheatEvents = cheatEvents.filter(e => e.time >= cutoff);

        const lastSix = cheatEvents.slice(-6);
        if (lastSix.length === 6) {
          const pattern = lastSix.map(e => e.symbol).join("");
          if (pattern === "DDDUUU" && !gameOver) {
            invincible = true;
            invincibleTimer = Math.max(invincibleTimer, CFG_CHEAT_INVINCIBLE_DURATION);
            player.classList.add("invincible");
            cheatTimerEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á: PHANToM ‡∏≠‡∏°‡∏ï‡∏∞ 10 ‡∏ß‡∏¥ üéÉ";
            messageEl.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÇ‡∏Å‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß! ‡∏ä‡∏ô‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢ 10 ‡∏ß‡∏¥";
            cheatEvents = [];
          }
        }
      }

      function toggleFullscreen(){
        const elem = document.documentElement;
        if (!document.fullscreenElement){
          if (elem.requestFullscreen) elem.requestFullscreen();
          else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
          else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          else if (document.msExitFullscreen) document.msExitFullscreen();
        }
      }

      if (fullscreenBtn){
        fullscreenBtn.addEventListener("click",(e)=>{
          e.preventDefault();
          toggleFullscreen();
        });
      }

      document.addEventListener("fullscreenchange", () => {
        if (!fullscreenBtn) return;
        if (document.fullscreenElement){
          fullscreenBtn.textContent = "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠";
          document.body.classList.add("fullscreen-game");
        } else {
          fullscreenBtn.textContent = "‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠";
          document.body.classList.remove("fullscreen-game");
        }
      });

      // ‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          if (gameOver) resetGame();
          else handleJump();
          registerCheat(e.code);
        } else if (e.code === "ArrowDown") {
          e.preventDefault();
          setDuck(true);
          registerCheat(e.code);
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "ArrowDown") setDuck(false);
      });

      // ‡∏õ‡∏∏‡πà‡∏°‡∏ö‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
      if (btnJump) {
        btnJump.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          if (gameOver) resetGame();
          else handleJump();
          registerCheat("Space");
        });
      }

      if (btnDuck) {
        btnDuck.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          setDuck(true);
          registerCheat("ArrowDown");
        });
        btnDuck.addEventListener("pointerup", (e) => {
          e.preventDefault();
          setDuck(false);
        });
        btnDuck.addEventListener("pointercancel", (e) => {
          e.preventDefault();
          setDuck(false);
        });
        btnDuck.addEventListener("pointerleave", (e) => {
          if (isDucking) setDuck(false);
        });
      }

      startBtn.addEventListener("click", resetGame);
      restartFromModalBtn.addEventListener("click", resetGame);
      reviveBtn.addEventListener("click", reviveGame);

      // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
      updateEnergyUI();
      updateMissionUI();
      messageEl.textContent = '‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° / ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà" ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î Space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°';
    })();
  </script>
</body>
</html>
